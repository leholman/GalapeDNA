for (row in 1:length(sitePairwiseDist$End)){
sitePairwiseDist$Calcdistance[row] <-  costDistance(tr2,c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]))
print(row)
}
#this works but is stupid and slow
for (row in 1:length(sitePairwiseDist$End)){
sitePairwiseDist$Calcdistance[row] <-  costDistance(tr2,c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]),
distfun = gdistance::distHaversine)
print(row)
}
gdistance::costDistance
library(terra)
#Another solution
library(terra)
?leastCostPath
??leastCostPath
?shortestPath
row
test <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row])
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row])
row <- 22
test <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
View(test)
plot(test)
gebco.crop <- readRDS("mapBuilding/GalapBathy.rds")
#function to calculate break points for colours from https://www.benjaminbell.co.uk/2019/08/bathymetric-maps-in-r-colour-palettes.html
## x = raster, b1 & b2 = number of divisions for each sequence, r1 & r2 = rounding value
colbr <- function(x, b1=50, b2=50, r1=-2, r2=-2) {
# Min/max values of the raster (x)
mi <- cellStats(x, stat="min")-100
ma <- cellStats(x, stat="max")+100
# Create sequences, but only use unique numbers
s1 <- unique(round(seq(mi, 0, 0-mi/b1),r1))
s2 <- unique(round(seq(0, ma, ma/b2),r2))
# Combine sequence for our break points, removing duplicate 0
s3 <- c(s1, s2[-1])
# Create a list with the outputs
# [[1]] = length of the first sequence minus 1 (water)
# [[2]] = length of the second sequence minus 1 (land)
# [[3]] = The break points
x <- list(length(s1)-1, length(s2)-1, s3)
}
galap.br <- colbr(gebco.crop,b2=1)
# Get country shapefiles
eq <- getData("GADM", country="ECU", level=0)
# Colour palette
blue.col <- colorRampPalette(c("darkblue", "lightblue"))
plot(gebco.crop, col=c(blue.col(galap.br[[1]]), grey.colors(galap.br[[2]])), breaks=galap.br[[3]],axes = FALSE,box=F,legend = FALSE)
#plot(eq, add=TRUE)
points(metadata$lon2,metadata$lat2,pch=16, col='black',cex=1)
points(metadata$lon2,metadata$lat2,pch=16, col='white',cex=0.5)
plot(test)
lines(test)
plot(gebco.crop, col=c(blue.col(galap.br[[1]]), grey.colors(galap.br[[2]])), breaks=galap.br[[3]],axes = FALSE,box=F,legend = FALSE)
lines(test)
row <- 25
test <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
lines(test)
row <- 55
test <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
lines(test,col="yellow")
#plot(eq, add=TRUE)
points(metadata$lon2,metadata$lat2,pch=16, col='black',cex=1)
points(metadata$lon2,metadata$lat2,pch=16, col='white',cex=0.5)
?shortestPath
tr1
plot(tr1)
?transition
#
tr1 <- transition(gebco.crop2, transitionFunction="barriers", directions=16)
tr2 <- geoCorrection(tr1, type="c", multpl=TRUE)
View(tr1)
#Pull in galapagos
gebco.crop <- readRDS("mapBuilding/GalapBathy.rds")
gebco.crop2 <- gebco.crop
#
tr1 <- transition(gebco.crop2, transitionFunction="barriers", directions=16)
?geoCorrection
tr2 <- geoCorrection(tr1, type="r", multpl=TRUE)
View(tr1)
#
tr1 <- transition(gebco.crop2, transitionFunction="barriers", directions=16,intervalBreaks=0.5)
gebco.crop2@data@values <-as.factor(gebco.crop2@data@values)
#
tr1 <- transition(gebco.crop2, transitionFunction="barriers", directions=16)
tr2 <- geoCorrection(tr1, type="r", multpl=TRUE)
#set land to zero, sea to 1
gebco.crop2@data@values[gebco.crop2@data@values>-1] <-0
gebco.crop2@data@values[gebco.crop2@data@values<0] <-100
#Pull in galapagos
gebco.crop <- readRDS("mapBuilding/GalapBathy.rds")
gebco.crop2 <- gebco.crop
#set land to zero, sea to 1
gebco.crop2@data@values[gebco.crop2@data@values>-1] <-0
gebco.crop2@data@values[gebco.crop2@data@values<0] <-100
gebco.crop2@data@values <-as.factor(gebco.crop2@data@values)
#
tr1 <- transition(gebco.crop2, transitionFunction="mean", directions=16)
#
tr1 <- transition(gebco.crop2, transitionFunction=mean, directions=16)
tr2 <- geoCorrection(tr1, type="r", multpl=TRUE)
sitePairwiseDist$Flat <- metadatSites$lat2[match(sitePairwiseDist$Start,metadatSites$SiteID)]
sitePairwiseDist$Flon <- metadatSites$lon2[match(sitePairwiseDist$Start,metadatSites$SiteID)]
sitePairwiseDist$Tlat <- metadatSites$lat2[match(sitePairwiseDist$End,metadatSites$SiteID)]
sitePairwiseDist$Tlon <- metadatSites$lon2[match(sitePairwiseDist$End,metadatSites$SiteID)]
sitePairwiseDist$Calcdistance <- rep(NA,length(sitePairwiseDist$End))
test <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
lines(test)
#set land to zero, sea to 1
gebco.crop2@data@values[gebco.crop2@data@values>-1] <-0
gebco.crop2@data@values[gebco.crop2@data@values<0] <-10000000
#Pull in galapagos
gebco.crop <- readRDS("mapBuilding/GalapBathy.rds")
gebco.crop2 <- gebco.crop
#set land to zero, sea to 1
gebco.crop2@data@values[gebco.crop2@data@values>-1] <-0
gebco.crop2@data@values[gebco.crop2@data@values<0] <-10000000
gebco.crop2@data@values <-as.factor(gebco.crop2@data@values)
#
tr1 <- transition(gebco.crop2, transitionFunction=mean, directions=16)
tr2 <- geoCorrection(tr1, type="r", multpl=TRUE)
sitePairwiseDist$Flat <- metadatSites$lat2[match(sitePairwiseDist$Start,metadatSites$SiteID)]
sitePairwiseDist$Flon <- metadatSites$lon2[match(sitePairwiseDist$Start,metadatSites$SiteID)]
sitePairwiseDist$Tlat <- metadatSites$lat2[match(sitePairwiseDist$End,metadatSites$SiteID)]
sitePairwiseDist$Tlon <- metadatSites$lon2[match(sitePairwiseDist$End,metadatSites$SiteID)]
sitePairwiseDist$Calcdistance <- rep(NA,length(sitePairwiseDist$End))
test <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
lines(test)
lines(test,col="red")
row <- 89
test <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
lines(test,col="red")
row <- 98
test <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
lines(test,col="red")
gebco.crop2 <- gebco.crop
#set land to zero, sea to 1
gebco.crop2@data@values[gebco.crop2@data@values>-1] <-0
gebco.crop2@data@values[gebco.crop2@data@values<0] <-inf
gebco.crop2@data@values[gebco.crop2@data@values<0] <-Inf
#
tr1 <- transition(gebco.crop2, transitionFunction=mean, directions=16)
tr2 <- geoCorrection(tr1, type="r", multpl=TRUE)
sitePairwiseDist$Flat <- metadatSites$lat2[match(sitePairwiseDist$Start,metadatSites$SiteID)]
sitePairwiseDist$Flon <- metadatSites$lon2[match(sitePairwiseDist$Start,metadatSites$SiteID)]
sitePairwiseDist$Tlat <- metadatSites$lat2[match(sitePairwiseDist$End,metadatSites$SiteID)]
sitePairwiseDist$Tlon <- metadatSites$lon2[match(sitePairwiseDist$End,metadatSites$SiteID)]
sitePairwiseDist$Calcdistance <- rep(NA,length(sitePairwiseDist$End))
test <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
lines(test,col="blue")
row <- 22
test <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
lines(test,col="blue")
row <- 25
test <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
lines(test,col="blue")
row ,_ 45
row <- 45
test <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
lines(test,col="blue")
plot(gebco.crop, col=c(blue.col(galap.br[[1]]), grey.colors(galap.br[[2]])), breaks=galap.br[[3]],axes = FALSE,box=F,legend = FALSE)
#plot(eq, add=TRUE)
points(metadata$lon2,metadata$lat2,pch=16, col='black',cex=1)
points(metadata$lon2,metadata$lat2,pch=16, col='white',cex=0.5)
for (row in 1:25){
test <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
lines(test,col="blue")
}
View(test)
test$lines
test@lines
row <- 4
test <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
test
test@lines
rgeos::gLength(test)
install.packages(regos)
install.packages("regos")
?gLength
??gLength
st_line_sample(test, 0.001, type = "regular"
)
row
row <- 4
test <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
install.packages("sf")
library('sf')
st_line_sample(test, 0.001, type = "regular")
st_line_sample(st_transform(test, 3857), density = c(1/100))
test <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
st_transform(test, 3857)
?st_transform()
ls = st_sfc(st_linestring(rbind(c(0,0),c(0,1))),
st_linestring(rbind(c(0,0),c(.1,0))), crs = 4326)
?spsample
testpoints <- spsample(test,100,regular)
testpoints <- spsample(test,100,type="regular")
points(testpoints,col="red",pch="16",cex=0.5)
testpoints <- spsample(test,10,regular)
points(testpoints,col="red",pch="16",cex=0.5)
testpoints <- spsample(test,10,regular)
points(testpoints,col="blue",pch="16",cex=0.5)
View(testpoints)
testpoints <- spsample(test,10,regular)
testpoints <- spsample(test,10,type = "regular")
points(testpoints,col="purple",pch="16",cex=0.5)
points(testpoints,col="purple",cex=1.0)
lengthLine(test)
library(geosphere)
install.packages("geosphere")
library(geosphere)
lengthLine(test)
looplen <- lengthLine(test)
testpoints <- spsample(test,looplen/100,regular)
testpoints <- spsample(test,looplen/100,type="regular")
plot(testpoints)
plot(gebco.crop, col=c(blue.col(galap.br[[1]]), grey.colors(galap.br[[2]])), breaks=galap.br[[3]],axes = FALSE,box=F,legend = FALSE)
#plot(eq, add=TRUE)
points(metadata$lon2,metadata$lat2,pch=16, col='black',cex=1)
points(metadata$lon2,metadata$lat2,pch=16, col='white',cex=0.5)
test <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
st_line_sample(test, 0.001, type = "regular")
st_line_sample(st_transform(test, 3857), density = c(1/100))
library(geosphere)
looplen <- lengthLine(test)
testpoints <- spsample(test,looplen/100,type="regular")
points(testpoints,col="red",cex=0.5,pch=16)
for (row in 1:25){
test <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
#lines(test,col="blue")
looplen <- lengthLine(test)
testpoints <- spsample(test,looplen/1000,type="regular")
points(testpoints,col="purple",cex=0.2,pch=16)
}
row <- 1
test <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
looplen <- lengthLine(test)
test
View(sitePairwiseDist)
for (row in 1:25){
if(sitePairwiseDist$Start==sitePairwiseDist$End){next()}
test <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
#lines(test,col="blue")
looplen <- lengthLine(test)
testpoints <- spsample(test,looplen/1000,type="regular")
points(testpoints,col="purple",cex=0.2,pch=16)
}
for (row in 1:25){
if(sitePairwiseDist$Start[row]==sitePairwiseDist$End[row]){next()}
test <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
#lines(test,col="blue")
looplen <- lengthLine(test)
testpoints <- spsample(test,looplen/1000,type="regular")
points(testpoints,col="purple",cex=0.2,pch=16)
}
View(testpoints)
#get the shortest path
loopPath <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
#calculate the distance of the shortest path
looplen <- lengthLine(loopPath)
row
row <- 27
#get the shortest path
loopPath <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
#calculate the distance of the shortest path
looplen <- lengthLine(loopPath)
#sample points along the path every 1000 metres
loopPathpoints <- spsample(loopPath,looplen/1000,type="regular")
loopPathpoints
length(loopPathpoints)
View(sitePairwiseDist)
#create point output table
loopPathPointsize <- length(loopPathpoints)
View(loopPathpoints)
loopPathpoints@coords[,1]
loopPathpoints@coords[,2]
loopPointsTable <- data.frame("Order"=1:loopPathPointsize,
"Start"=rep(sitePairwiseDist$Start[row],loopPathPointsize),
"End"=rep(sitePairwiseDist$End[row],loopPathPointsize),
"lon"=loopPathpoints@coords[,1],
"lat"=loopPathpoints@coords[,2])
View(loopPointsTable)
pathPointsTable <- c()
#for (row in 1:length(sitePairwiseDist$End)){
for (row in 1:25){
#set dist to zero and skip loop for comparing a site to itself
if(sitePairwiseDist$Start[row]==sitePairwiseDist$End[row]){sitePairwiseDist$Calcdistance[row] <- 0
next()}
#get the shortest path
loopPath <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
#calculate the distance of the shortest path
looplen <- lengthLine(loopPath)
#sample points along the path every 1000 metres
loopPathpoints <- spsample(loopPath,looplen/1000,type="regular")
#output lengths to dataframe
sitePairwiseDist$Calcdistance[row] <- looplen
#create point output table
loopPathPointsize <- length(loopPathpoints)
loopPointsTable <- data.frame("Order"=1:loopPathPointsize,
"Start"=rep(sitePairwiseDist$Start[row],loopPathPointsize),
"End"=rep(sitePairwiseDist$End[row],loopPathPointsize),
"lon"=loopPathpoints@coords[,1],
"lat"=loopPathpoints@coords[,2])
pathPointsTable <- rbind(pathPointsTable,loopPointsTable)
print(row)
}
sitePairwiseDist <- expand.grid(Start=metadatSites$SiteID,
End=metadatSites$SiteID)
sitePairwiseDist$Flat <- metadatSites$lat2[match(sitePairwiseDist$Start,metadatSites$SiteID)]
sitePairwiseDist$Flon <- metadatSites$lon2[match(sitePairwiseDist$Start,metadatSites$SiteID)]
sitePairwiseDist$Tlat <- metadatSites$lat2[match(sitePairwiseDist$End,metadatSites$SiteID)]
sitePairwiseDist$Tlon <- metadatSites$lon2[match(sitePairwiseDist$End,metadatSites$SiteID)]
sitePairwiseDist$Calcdistance <- rep(NA,length(sitePairwiseDist$End))
pathPointsTable <- c()
#for (row in 1:length(sitePairwiseDist$End)){
for (row in 1:25){
#set dist to zero and skip loop for comparing a site to itself
if(sitePairwiseDist$Start[row]==sitePairwiseDist$End[row]){sitePairwiseDist$Calcdistance[row] <- 0
next()}
#get the shortest path
loopPath <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
#calculate the distance of the shortest path
looplen <- lengthLine(loopPath)
#sample points along the path every 1000 metres
loopPathpoints <- spsample(loopPath,looplen/1000,type="regular")
#output lengths to dataframe
sitePairwiseDist$Calcdistance[row] <- looplen
#create point output table
loopPathPointsize <- length(loopPathpoints)
loopPointsTable <- data.frame("Order"=1:loopPathPointsize,
"Start"=rep(sitePairwiseDist$Start[row],loopPathPointsize),
"End"=rep(sitePairwiseDist$End[row],loopPathPointsize),
"lon"=loopPathpoints@coords[,1],
"lat"=loopPathpoints@coords[,2])
pathPointsTable <- rbind(pathPointsTable,loopPointsTable)
print(row)
}
View(sitePairwiseDist)
View(loopPointsTable)
View(pathPointsTable)
#calculate some distances 'as-the-fish-swims'
library('gdistance')
library('sf')
library('geosphere')
#Pull in galapagos
gebco.crop <- readRDS("mapBuilding/GalapBathy.rds")
gebco.crop2 <- gebco.crop
#set land to zero, sea to 1
gebco.crop2@data@values[gebco.crop2@data@values>-1] <-0
gebco.crop2@data@values[gebco.crop2@data@values<0] <-Inf
#Places
metadatSites <- read.csv("metadata.site.out.csv",row.names=1)
places <- cbind(metadatSites$lon2,metadatSites$lat2)
sitePairwiseDist <- expand.grid(Start=metadatSites$SiteID,
End=metadatSites$SiteID)
#
tr1 <- transition(gebco.crop2, transitionFunction=mean, directions=16)
tr2 <- geoCorrection(tr1, type="r", multpl=TRUE)
sitePairwiseDist$Flat <- metadatSites$lat2[match(sitePairwiseDist$Start,metadatSites$SiteID)]
sitePairwiseDist$Flon <- metadatSites$lon2[match(sitePairwiseDist$Start,metadatSites$SiteID)]
sitePairwiseDist$Tlat <- metadatSites$lat2[match(sitePairwiseDist$End,metadatSites$SiteID)]
sitePairwiseDist$Tlon <- metadatSites$lon2[match(sitePairwiseDist$End,metadatSites$SiteID)]
sitePairwiseDist$Calcdistance <- rep(NA,length(sitePairwiseDist$End))
pathPointsTable <- c()
for (row in 1:length(sitePairwiseDist$End)){
#for (row in 1:25){
#set dist to zero and skip loop for comparing a site to itself
if(sitePairwiseDist$Start[row]==sitePairwiseDist$End[row]){sitePairwiseDist$Calcdistance[row] <- 0
next()}
#get the shortest path
loopPath <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
#calculate the distance of the shortest path
looplen <- lengthLine(loopPath)
#sample points along the path every 1000 metres
loopPathpoints <- spsample(loopPath,looplen/1000,type="regular")
#output lengths to dataframe
sitePairwiseDist$Calcdistance[row] <- looplen
#create point output table
loopPathPointsize <- length(loopPathpoints)
loopPointsTable <- data.frame("Order"=1:loopPathPointsize,
"Start"=rep(sitePairwiseDist$Start[row],loopPathPointsize),
"End"=rep(sitePairwiseDist$End[row],loopPathPointsize),
"lon"=loopPathpoints@coords[,1],
"lat"=loopPathpoints@coords[,2])
pathPointsTable <- rbind(pathPointsTable,loopPointsTable)
print(row)
}
View(pathPointsTable)
# Load packages
library(ncdf4)
library(raster)
gebco.crop <- readRDS("mapBuilding/GalapBathy.rds")
#load lat lon
metadata <- read.csv(file = "metadata.site.out.csv")
#function to calculate break points for colours from https://www.benjaminbell.co.uk/2019/08/bathymetric-maps-in-r-colour-palettes.html
## x = raster, b1 & b2 = number of divisions for each sequence, r1 & r2 = rounding value
colbr <- function(x, b1=50, b2=50, r1=-2, r2=-2) {
# Min/max values of the raster (x)
mi <- cellStats(x, stat="min")-100
ma <- cellStats(x, stat="max")+100
# Create sequences, but only use unique numbers
s1 <- unique(round(seq(mi, 0, 0-mi/b1),r1))
s2 <- unique(round(seq(0, ma, ma/b2),r2))
# Combine sequence for our break points, removing duplicate 0
s3 <- c(s1, s2[-1])
# Create a list with the outputs
# [[1]] = length of the first sequence minus 1 (water)
# [[2]] = length of the second sequence minus 1 (land)
# [[3]] = The break points
x <- list(length(s1)-1, length(s2)-1, s3)
}
galap.br <- colbr(gebco.crop,b2=1)
# Get country shapefiles
eq <- getData("GADM", country="ECU", level=0)
# Colour palette
blue.col <- colorRampPalette(c("darkblue", "lightblue"))
plot(gebco.crop, col=c(blue.col(galap.br[[1]]), grey.colors(galap.br[[2]])), breaks=galap.br[[3]],axes = FALSE,box=F,legend = FALSE)
#plot(eq, add=TRUE)
points(metadata$lon2,metadata$lat2,pch=16, col='black',cex=1)
points(metadata$lon2,metadata$lat2,pch=16, col='white',cex=0.5)
points(pathPointsTable$lon,pathPointsTable$lat,col="darkgreen",pch=16,cex=0.2)
View(sitePairwiseDist)
write.csv(pathPointsTable,"pathPointsTable.csv")
write.csv(sitePairwiseDist,"SiteDistance.csv")
write.csv(pathPointsTable,"pathPointsTable.csv")
