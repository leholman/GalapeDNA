##Function 3 Calculate a the angle (azimuth) between two geographic points with lat lon
azimuth <- function(lat1, lon1, lat2, lon2) {
# Convert decimal degrees to radians
lat1 <- lat1 * pi / 180
lon1 <- lon1 * pi / 180
lat2 <- lat2 * pi / 180
lon2 <- lon2 * pi / 180
# Calculate the difference in longitude
delta_lon <- lon2 - lon1
# Calculate the azimuth (bearing) using the Haversine formula
y <- sin(delta_lon) * cos(lat2)
x <- cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(delta_lon)
azimuth_rad <- atan2(y, x)
# Convert radians to degrees
azimuth_deg <- azimuth_rad * 180 / pi
# Make sure the result is in the range [0, 360)
if (azimuth_deg < 0) {
azimuth_deg <- azimuth_deg + 360
}
return(azimuth_deg)
}
#testing
azimuth(55.68517608483797, 12.57629649327822,55.66184699523609, 12.57955805920173)
##Function 4 Calculate the azimuth difference from angle A to angle B
angleCalc <- function(A,B){
input <- B - A
if (input > 0){
return(input)} else
if (input < 0) {
return(input+360)} else
if (input == 0){return(0)}
}
##Function 5 scale an azimuth angle into resistance with 1 being 0 degrees and -1 being 180 degrees
cosTrans <- function(input){
return(cos((input/360)*(2*pi)))
}
####====2.2 Calculate distance on real data ====####
## 1 Calculate angle and magnitude of each lat lon point along the path
#angle
modeldat$resultantAngle <- unlist(mapply(vectorAngle,modeldat$UVEL,modeldat$VVEL))
#magnitude
modeldat$magnitudes <- unlist(mapply(vectorSum,modeldat$UVEL,modeldat$VVEL))
## 2 Create an output dataframe for each journey
modeldat$journeyID <- paste(modeldat$Start,modeldat$End,sep="_")
journeyOutput <- data.frame("journeyID"=unique(paste(modeldat$Start,modeldat$End,sep="_")),"OceanographicResistance"=rep(0,length(unique(paste(modeldat$Start,modeldat$End,sep="_")))))
## 3 loop over each journey
for (journeyIndex in 1:length(journeyOutput$journeyID)){
# journeyIndex <- 8
loopJourney <- journeyOutput$journeyID[journeyIndex]
loopData <- modeldat[modeldat$journeyID==loopJourney,]
loopData$comparisonAngle <- NA
loopData$comparisonAngleDiff <- NA
loopData$comparisonAngleMetric <- NA
loopData$comparisonMetric <- NA
for (loopLocation in 1:length(loopData$Order)){
if(loopData$Order[loopLocation]==max(loopData$Order)){next()}
index <- match(loopData$Order[loopLocation],loopData$Order)
index2 <- match(loopData$Order[loopLocation+1],loopData$Order)
loopData$comparisonAngle[index] <- azimuth(loopData$lat[index],loopData$lon[index],loopData$lat[index2],loopData$lon[index2])
loopData$comparisonAngleDiff[index] <- angleCalc(loopData$comparisonAngle[index],loopData$resultantAngle[index])
loopData$comparisonAngleMetric[index] <- cosTrans(loopData$comparisonAngleDiff[index])
loopData$comparisonMetric[index] <- loopData$comparisonAngleMetric[index] * loopData$magnitudes[index]
}
journeyOutput$OceanographicResistance[journeyIndex] <-mean(loopData$comparisonMetric,na.rm = T)
}
View(journeyOutput)
View(journeyOutput)
journeyOutput$journeyID =="CORA_SUAR"
View(journeyOutput)
match(journeyOutput$journeyID,"CORA_SUAR")
match("CORA_SUAR",journeyOutput$journeyID)
loopJourney <- "CORA_SUAR"
checkdat <- modeldat[modeldat$journeyID==loopJourney,]
View(checkdat)
hist(checkdat$resultantAngle)
hist(checkdat$resultantAngle,breaks=180)
hist(checkdat$magnitudes,breaks=180)
loopData <- modeldat[modeldat$journeyID==loopJourney,]
loopData$comparisonAngle <- NA
loopData$comparisonAngleDiff <- NA
loopData$comparisonAngleMetric <- NA
loopData$comparisonMetric <- NA
for (loopLocation in 1:length(loopData$Order)){
if(loopData$Order[loopLocation]==max(loopData$Order)){next()}
index <- match(loopData$Order[loopLocation],loopData$Order)
index2 <- match(loopData$Order[loopLocation+1],loopData$Order)
loopData$comparisonAngle[index] <- azimuth(loopData$lat[index],loopData$lon[index],loopData$lat[index2],loopData$lon[index2])
loopData$comparisonAngleDiff[index] <- angleCalc(loopData$comparisonAngle[index],loopData$resultantAngle[index])
loopData$comparisonAngleMetric[index] <- cosTrans(loopData$comparisonAngleDiff[index])
loopData$comparisonMetric[index] <- loopData$comparisonAngleMetric[index] * loopData$magnitudes[index]
}
View(loopData)
View(journeyOutput)
CORA_SUAR <- loopData
loopJourney <- "SUAR_CORA"
loopData <- modeldat[modeldat$journeyID==loopJourney,]
View(loopData)
loopData$comparisonAngle <- NA
loopData$comparisonAngleDiff <- NA
loopData$comparisonAngleMetric <- NA
loopData$comparisonMetric <- NA
for (loopLocation in 1:length(loopData$Order)){
if(loopData$Order[loopLocation]==max(loopData$Order)){next()}
index <- match(loopData$Order[loopLocation],loopData$Order)
index2 <- match(loopData$Order[loopLocation+1],loopData$Order)
loopData$comparisonAngle[index] <- azimuth(loopData$lat[index],loopData$lon[index],loopData$lat[index2],loopData$lon[index2])
loopData$comparisonAngleDiff[index] <- angleCalc(loopData$comparisonAngle[index],loopData$resultantAngle[index])
loopData$comparisonAngleMetric[index] <- cosTrans(loopData$comparisonAngleDiff[index])
loopData$comparisonMetric[index] <- loopData$comparisonAngleMetric[index] * loopData$magnitudes[index]
}
View(loopData)
View(CORA_SUAR)
loopJourney <- "CORA_PCAL"
loopJourney <- journeyOutput$journeyID[journeyIndex]
loopData <- modeldat[modeldat$journeyID==loopJourney,]
loopData$comparisonAngle <- NA
loopData$comparisonAngleDiff <- NA
loopData$comparisonAngleMetric <- NA
loopData$comparisonMetric <- NA
for (loopLocation in 1:length(loopData$Order)){
if(loopData$Order[loopLocation]==max(loopData$Order)){next()}
index <- match(loopData$Order[loopLocation],loopData$Order)
index2 <- match(loopData$Order[loopLocation+1],loopData$Order)
loopData$comparisonAngle[index] <- azimuth(loopData$lat[index],loopData$lon[index],loopData$lat[index2],loopData$lon[index2])
loopData$comparisonAngleDiff[index] <- angleCalc(loopData$comparisonAngle[index],loopData$resultantAngle[index])
loopData$comparisonAngleMetric[index] <- cosTrans(loopData$comparisonAngleDiff[index])
loopData$comparisonMetric[index] <- loopData$comparisonAngleMetric[index] * loopData$magnitudes[index]
}
View(loopData)
loopJourney <- "CORA_PCAL"
loopJourney <- "CORA_PCAL"
checkdat <- modeldat[modeldat$journeyID==loopJourney,]
View(checkdat)
loopData <- modeldat[modeldat$journeyID==loopJourney,]
loopData$comparisonAngle <- NA
loopData$comparisonAngleDiff <- NA
loopData$comparisonAngleMetric <- NA
loopData$comparisonMetric <- NA
for (loopLocation in 1:length(loopData$Order)){
if(loopData$Order[loopLocation]==max(loopData$Order)){next()}
index <- match(loopData$Order[loopLocation],loopData$Order)
index2 <- match(loopData$Order[loopLocation+1],loopData$Order)
loopData$comparisonAngle[index] <- azimuth(loopData$lat[index],loopData$lon[index],loopData$lat[index2],loopData$lon[index2])
loopData$comparisonAngleDiff[index] <- angleCalc(loopData$comparisonAngle[index],loopData$resultantAngle[index])
loopData$comparisonAngleMetric[index] <- cosTrans(loopData$comparisonAngleDiff[index])
loopData$comparisonMetric[index] <- loopData$comparisonAngleMetric[index] * loopData$magnitudes[index]
}
View(loopData)
hist(checkdat$resultantAngle,breaks=180)
hist(checkdat$magnitudes,breaks=180)
hist(checkdat$resultantAngle,breaks=180)
hist(loopData$comparisonAngle)
View(loopData)
View(checkdat)
View(journeyOutput)
loopJourney <- "CORA_PESP"
loopJourney <- journeyOutput$journeyID[journeyIndex]
loopData <- modeldat[modeldat$journeyID==loopJourney,]
loopData$comparisonAngle <- NA
loopData$comparisonAngleDiff <- NA
loopData$comparisonAngleMetric <- NA
loopData$comparisonMetric <- NA
for (loopLocation in 1:length(loopData$Order)){
if(loopData$Order[loopLocation]==max(loopData$Order)){next()}
index <- match(loopData$Order[loopLocation],loopData$Order)
index2 <- match(loopData$Order[loopLocation+1],loopData$Order)
loopData$comparisonAngle[index] <- azimuth(loopData$lat[index],loopData$lon[index],loopData$lat[index2],loopData$lon[index2])
loopData$comparisonAngleDiff[index] <- angleCalc(loopData$comparisonAngle[index],loopData$resultantAngle[index])
loopData$comparisonAngleMetric[index] <- cosTrans(loopData$comparisonAngleDiff[index])
loopData$comparisonMetric[index] <- loopData$comparisonAngleMetric[index] * loopData$magnitudes[index]
}
View(loopData)
loopJourney <- "CORA_PESP"
loopData <- modeldat[modeldat$journeyID==loopJourney,]
loopData$comparisonAngle <- NA
loopData$comparisonAngleDiff <- NA
loopData$comparisonAngleMetric <- NA
loopData$comparisonMetric <- NA
for (loopLocation in 1:length(loopData$Order)){
if(loopData$Order[loopLocation]==max(loopData$Order)){next()}
index <- match(loopData$Order[loopLocation],loopData$Order)
index2 <- match(loopData$Order[loopLocation+1],loopData$Order)
loopData$comparisonAngle[index] <- azimuth(loopData$lat[index],loopData$lon[index],loopData$lat[index2],loopData$lon[index2])
loopData$comparisonAngleDiff[index] <- angleCalc(loopData$comparisonAngle[index],loopData$resultantAngle[index])
loopData$comparisonAngleMetric[index] <- cosTrans(loopData$comparisonAngleDiff[index])
loopData$comparisonMetric[index] <- loopData$comparisonAngleMetric[index] * loopData$magnitudes[index]
}
View(loopData)
plot(loopData$lon,loopData$lat)
plot(gebco.crop, col=c(blue.col(galap.br[[1]]), grey.colors(galap.br[[2]])), breaks=galap.br[[3]],axes = FALSE,box=F,legend = FALSE)
#plot(eq, add=TRUE)
points(metadata$lon2,metadata$lat2,pch=16, col='black',cex=1)
points(metadata$lon2,metadata$lat2,pch=16, col='white',cex=0.5)
text(metadata$lon2,metadata$lat2+0.1,labels=metadata$SiteID,col='white',cex=0.6)
text(metadata$lon2,metadata$lat2+0.1,labels=metadata$SiteID,col='black',cex=0.55)
gebco.crop <- readRDS("mapBuilding/GalapBathy.rds")
#load lat lon
metadata <- read.csv(file = "metadata.site.out.csv")
#function to calculate break points for colours from https://www.benjaminbell.co.uk/2019/08/bathymetric-maps-in-r-colour-palettes.html
## x = raster, b1 & b2 = number of divisions for each sequence, r1 & r2 = rounding value
colbr <- function(x, b1=50, b2=50, r1=-2, r2=-2) {
# Min/max values of the raster (x)
mi <- cellStats(x, stat="min")-100
ma <- cellStats(x, stat="max")+100
# Create sequences, but only use unique numbers
s1 <- unique(round(seq(mi, 0, 0-mi/b1),r1))
s2 <- unique(round(seq(0, ma, ma/b2),r2))
# Combine sequence for our break points, removing duplicate 0
s3 <- c(s1, s2[-1])
# Create a list with the outputs
# [[1]] = length of the first sequence minus 1 (water)
# [[2]] = length of the second sequence minus 1 (land)
# [[3]] = The break points
x <- list(length(s1)-1, length(s2)-1, s3)
}
galap.br <- colbr(gebco.crop,b2=1)
# Get country shapefiles
eq <- getData("GADM", country="ECU", level=0)
# Colour palette
blue.col <- colorRampPalette(c("darkblue", "lightblue"))
#First plot
pdf(width = 8,height=6.5,file="mapBuilding/test1.pdf")
plot(gebco.crop, col=c(blue.col(galap.br[[1]]), grey.colors(galap.br[[2]])), breaks=galap.br[[3]],axes = FALSE,box=F,legend = FALSE)
#plot(eq, add=TRUE)
points(metadata$lon2,metadata$lat2,pch=16, col='black',cex=1)
points(metadata$lon2,metadata$lat2,pch=16, col='white',cex=0.5)
dev.off()
#Adding in colours per island
cols <- c("#80B1D3","#FFFFB3","#FFFFB3","#80B1D3","#FB8072","#BEBADA","#FFED6F","#CCEBC5",
"#80B1D3","#8DD3C7","#FDB462","#FFFFB3","#B3DE69","gray85","#FFFFB3","#80B1D3",
"#FCCDE5","#80B1D3","#80B1D3","#CCEBC5","#BC80BD","#8DD3C7","#80B1D3")
pdf(width = 8,height=6.5,file="mapBuilding/test2.pdf")
plot(gebco.crop, col=c(blue.col(galap.br[[1]]), grey.colors(galap.br[[2]])), breaks=galap.br[[3]],axes = FALSE,box=F,legend = FALSE)
#plot(eq, add=TRUE)
points(metadata$lon2,metadata$lat2,pch=16, col='black',cex=3)
points(metadata$lon2,metadata$lat2,pch=16, col=cols,cex=2)
dev.off()
### playground basement
pathPointsTable <- read.csv("pathPointsTable.csv",row.names = 1)
plot(gebco.crop, col=c(blue.col(galap.br[[1]]), grey.colors(galap.br[[2]])), breaks=galap.br[[3]],axes = FALSE,box=F,legend = FALSE)
#plot(eq, add=TRUE)
points(metadata$lon2,metadata$lat2,pch=16, col='black',cex=1)
points(metadata$lon2,metadata$lat2,pch=16, col='white',cex=0.5)
text(metadata$lon2,metadata$lat2+0.1,labels=metadata$SiteID,col='white',cex=0.6)
text(metadata$lon2,metadata$lat2+0.1,labels=metadata$SiteID,col='black',cex=0.55)
points(loopData$lon,loopData$lat,cex=0.5,lty=16,col="red")
hist(loopData$comparisonMetric)
sd
sd(loopData$comparisonMetric,na.rm = T)
modeldat$journeyID <- paste(modeldat$Start,modeldat$End,sep="_")
journeyOutput <- data.frame("journeyID"=unique(paste(modeldat$Start,modeldat$End,sep="_")),"OceanographicResistance"=rep(0,length(unique(paste(modeldat$Start,modeldat$End,sep="_")))),"OceanographicResistanceSD"=rep(0,length(unique(paste(modeldat$Start,modeldat$End,sep="_")))))
for (journeyIndex in 1:length(journeyOutput$journeyID)){
# journeyIndex <- 8
loopJourney <- journeyOutput$journeyID[journeyIndex]
loopData <- modeldat[modeldat$journeyID==loopJourney,]
loopData$comparisonAngle <- NA
loopData$comparisonAngleDiff <- NA
loopData$comparisonAngleMetric <- NA
loopData$comparisonMetric <- NA
for (loopLocation in 1:length(loopData$Order)){
if(loopData$Order[loopLocation]==max(loopData$Order)){next()}
index <- match(loopData$Order[loopLocation],loopData$Order)
index2 <- match(loopData$Order[loopLocation+1],loopData$Order)
loopData$comparisonAngle[index] <- azimuth(loopData$lat[index],loopData$lon[index],loopData$lat[index2],loopData$lon[index2])
loopData$comparisonAngleDiff[index] <- angleCalc(loopData$comparisonAngle[index],loopData$resultantAngle[index])
loopData$comparisonAngleMetric[index] <- cosTrans(loopData$comparisonAngleDiff[index])
loopData$comparisonMetric[index] <- loopData$comparisonAngleMetric[index] * loopData$magnitudes[index]
}
journeyOutput$OceanographicResistance[journeyIndex] <-mean(loopData$comparisonMetric,na.rm = T)
journeyOutput$OceanographicResistanceSD[journeyIndex] <-sd(loopData$comparisonMetric,na.rm = T)
}
modeldat$journeyID <- paste(modeldat$Start,modeldat$End,sep="_")
journeyOutput <- data.frame("journeyID"=unique(paste(modeldat$Start,modeldat$End,sep="_")),"OceanographicResistance"=rep(0,length(unique(paste(modeldat$Start,modeldat$End,sep="_")))),"OceanographicResistanceSD"=rep(0,length(unique(paste(modeldat$Start,modeldat$End,sep="_")))))
for (journeyIndex in 1:length(journeyOutput$journeyID)){
# journeyIndex <- 8
loopJourney <- journeyOutput$journeyID[journeyIndex]
loopData <- modeldat[modeldat$journeyID==loopJourney,]
loopData$comparisonAngle <- NA
loopData$comparisonAngleDiff <- NA
loopData$comparisonAngleMetric <- NA
loopData$comparisonMetric <- NA
for (loopLocation in 1:length(loopData$Order)){
if(loopData$Order[loopLocation]==max(loopData$Order)){next()}
index <- match(loopData$Order[loopLocation],loopData$Order)
index2 <- match(loopData$Order[loopLocation+1],loopData$Order)
loopData$comparisonAngle[index] <- azimuth(loopData$lat[index],loopData$lon[index],loopData$lat[index2],loopData$lon[index2])
loopData$comparisonAngleDiff[index] <- angleCalc(loopData$comparisonAngle[index],loopData$resultantAngle[index])
loopData$comparisonAngleMetric[index] <- cosTrans(loopData$comparisonAngleDiff[index])
loopData$comparisonMetric[index] <- loopData$comparisonAngleMetric[index] * loopData$magnitudes[index]
}
journeyOutput$OceanographicResistance[journeyIndex] <-mean(loopData$comparisonMetric,na.rm = T)
journeyOutput$OceanographicResistanceSD[journeyIndex] <-sd(loopData$comparisonMetric,na.rm = T)
}
View(journeyOutput)
#calculate some distances 'as-the-fish-swims'
####====0.0 Packages====####
library('gdistance')
library('sf')
library('geosphere')
####====1.0 As-the-fish-swims Distance & Points  ====####
#Pull in galapagos
gebco.crop <- readRDS("mapBuilding/GalapBathy.rds")
gebco.crop2 <- gebco.crop
#set land to zero, sea to 1
gebco.crop2@data@values[gebco.crop2@data@values>-1] <-0
gebco.crop2@data@values[gebco.crop2@data@values<0] <-Inf
#Places
metadatSites <- read.csv("metadata.site.out.csv",row.names=1)
places <- cbind(metadatSites$lon2,metadatSites$lat2)
sitePairwiseDist <- expand.grid(Start=metadatSites$SiteID,
End=metadatSites$SiteID)
#
tr1 <- transition(gebco.crop2, transitionFunction=mean, directions=16)
tr2 <- geoCorrection(tr1, type="r", multpl=TRUE)
sitePairwiseDist$Flat <- metadatSites$lat2[match(sitePairwiseDist$Start,metadatSites$SiteID)]
sitePairwiseDist$Flon <- metadatSites$lon2[match(sitePairwiseDist$Start,metadatSites$SiteID)]
sitePairwiseDist$Tlat <- metadatSites$lat2[match(sitePairwiseDist$End,metadatSites$SiteID)]
sitePairwiseDist$Tlon <- metadatSites$lon2[match(sitePairwiseDist$End,metadatSites$SiteID)]
sitePairwiseDist$Calcdistance <- rep(NA,length(sitePairwiseDist$End))
#empty points table
pathPointsTable <- c()
#Loop over site comparisons and output needed data
for (row in 1:length(sitePairwiseDist$End)){
#set dist to zero and skip loop for comparing a site to itself
if(sitePairwiseDist$Start[row]==sitePairwiseDist$End[row]){sitePairwiseDist$Calcdistance[row] <- 0
next()}
#get the shortest path
loopPath <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
#calculate the distance of the shortest path
looplen <- lengthLine(loopPath)
#sample points along the path every 1000 metres
loopPathpoints <- spsample(loopPath,looplen/1000,type="regular")
#output lengths to dataframe
sitePairwiseDist$Calcdistance[row] <- looplen
#create point output table
loopPathPointsize <- length(loopPathpoints)
loopPointsTable <- data.frame("Order"=1:loopPathPointsize,
"Start"=rep(sitePairwiseDist$Start[row],loopPathPointsize),
"End"=rep(sitePairwiseDist$End[row],loopPathPointsize),
"lon"=loopPathpoints@coords[,1],
"lat"=loopPathpoints@coords[,2])
pathPointsTable <- rbind(pathPointsTable,loopPointsTable)
print(row)
}
write.csv(sitePairwiseDist,"SiteDistance.csv")
write.csv(pathPointsTable,"pathPointsTable.csv")
## Now these lat long points are used to pull the model data in
####====2.0 Oceanographic Distance  ====####
modeldat <-read.csv("pathPoints/pathPointsTable_Sep.csv")
modeldatLAND <- modeldat[modeldat$VVEL==0,]
plot(modeldatLAND$lon,modeldatLAND$lat,pch=16,col="red",cex=0.4)
####====2.1 Functions for calculating distance ====####
##Function 1 - calculate the resultant angle from a Northing and an Easting
vectorAngle <- function(Northing,Easting){
if(Northing == 0 & Easting == 0){return(0)}
Northing=Northing+0.0000001
Easting=Easting+0.0000001
resultant_angle <- atan2(sqrt(Northing^2),sqrt(Easting^2))
resultant_angle_degrees <- (180/pi) * resultant_angle
if(Northing>0 & Easting>0){return(90-resultant_angle_degrees)} else
if(Northing<0 & Easting>0){return(90+resultant_angle_degrees)} else
if(Northing<0 & Easting<0){return(270-resultant_angle_degrees)} else
if(Northing>0 & Easting<0){return(270+resultant_angle_degrees)}
}
#resultant_angle_degrees <- ifelse(resultant_angle_degrees < 0, 360 + resultant_angle_degrees, resultant_angle_degrees)
#return(resultant_angle_degrees)}
#testing
vectorAngle(5,5)
vectorAngle(-5,5)
vectorAngle(-5,-5)
vectorAngle(5,-5)
##Function 2 Calculate a resultant magnitude of the vector from a Northign and an Easting
vectorSum <- function(Northing,Easting){
if(Northing == 0 & Easting == 0){return(NA)}
resultantMagnitude <- sqrt(Northing^2+Easting^2)
return(resultantMagnitude)}
modeldat$magnitudes <- unlist(mapply(vectorSum,modeldat$UVEL,modeldat$VVEL))
##Function 3 Calculate a the angle (azimuth) between two geographic points with lat lon
azimuth <- function(lat1, lon1, lat2, lon2) {
# Convert decimal degrees to radians
lat1 <- lat1 * pi / 180
lon1 <- lon1 * pi / 180
lat2 <- lat2 * pi / 180
lon2 <- lon2 * pi / 180
# Calculate the difference in longitude
delta_lon <- lon2 - lon1
# Calculate the azimuth (bearing) using the Haversine formula
y <- sin(delta_lon) * cos(lat2)
x <- cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(delta_lon)
azimuth_rad <- atan2(y, x)
# Convert radians to degrees
azimuth_deg <- azimuth_rad * 180 / pi
# Make sure the result is in the range [0, 360)
if (azimuth_deg < 0) {
azimuth_deg <- azimuth_deg + 360
}
return(azimuth_deg)
}
#testing
azimuth(55.68517608483797, 12.57629649327822,55.66184699523609, 12.57955805920173)
##Function 4 Calculate the azimuth difference from angle A to angle B
angleCalc <- function(A,B){
input <- B - A
if (input > 0){
return(input)} else
if (input < 0) {
return(input+360)} else
if (input == 0){return(0)}
}
##Function 5 scale an azimuth angle into resistance with 1 being 0 degrees and -1 being 180 degrees
cosTrans <- function(input){
return(cos((input/360)*(2*pi)))
}
####====2.2 Calculate distance on real data ====####
## 1 Calculate angle and magnitude of each lat lon point along the path
#angle
modeldat$resultantAngle <- unlist(mapply(vectorAngle,modeldat$UVEL,modeldat$VVEL))
#magnitude
modeldat$magnitudes <- unlist(mapply(vectorSum,modeldat$UVEL,modeldat$VVEL))
## 2 Create an output dataframe for each journey
modeldat$journeyID <- paste(modeldat$Start,modeldat$End,sep="_")
journeyOutput <- data.frame("journeyID"=unique(paste(modeldat$Start,modeldat$End,sep="_")),"OceanographicResistance"=rep(0,length(unique(paste(modeldat$Start,modeldat$End,sep="_")))),"OceanographicResistanceSD"=rep(0,length(unique(paste(modeldat$Start,modeldat$End,sep="_")))))
## 3 loop over each journey
for (journeyIndex in 1:length(journeyOutput$journeyID)){
# journeyIndex <- 8
loopJourney <- journeyOutput$journeyID[journeyIndex]
loopData <- modeldat[modeldat$journeyID==loopJourney,]
loopData$comparisonAngle <- NA
loopData$comparisonAngleDiff <- NA
loopData$comparisonAngleMetric <- NA
loopData$comparisonMetric <- NA
for (loopLocation in 1:length(loopData$Order)){
if(loopData$Order[loopLocation]==max(loopData$Order)){next()}
index <- match(loopData$Order[loopLocation],loopData$Order)
index2 <- match(loopData$Order[loopLocation+1],loopData$Order)
loopData$comparisonAngle[index] <- azimuth(loopData$lat[index],loopData$lon[index],loopData$lat[index2],loopData$lon[index2])
loopData$comparisonAngleDiff[index] <- angleCalc(loopData$comparisonAngle[index],loopData$resultantAngle[index])
loopData$comparisonAngleMetric[index] <- cosTrans(loopData$comparisonAngleDiff[index])
loopData$comparisonMetric[index] <- loopData$comparisonAngleMetric[index] * loopData$magnitudes[index]
}
journeyOutput$OceanographicResistance[journeyIndex] <-mean(loopData$comparisonMetric,na.rm = T)
journeyOutput$OceanographicResistanceSD[journeyIndex] <-sd(loopData$comparisonMetric,na.rm = T)
}
loopJourney <- "CHAM_PMOR"
loopData <- modeldat[modeldat$journeyID==loopJourney,]
loopData$comparisonAngle <- NA
loopData$comparisonAngleDiff <- NA
loopData$comparisonAngleMetric <- NA
loopData$comparisonMetric <- NA
for (loopLocation in 1:length(loopData$Order)){
if(loopData$Order[loopLocation]==max(loopData$Order)){next()}
index <- match(loopData$Order[loopLocation],loopData$Order)
index2 <- match(loopData$Order[loopLocation+1],loopData$Order)
loopData$comparisonAngle[index] <- azimuth(loopData$lat[index],loopData$lon[index],loopData$lat[index2],loopData$lon[index2])
loopData$comparisonAngleDiff[index] <- angleCalc(loopData$comparisonAngle[index],loopData$resultantAngle[index])
loopData$comparisonAngleMetric[index] <- cosTrans(loopData$comparisonAngleDiff[index])
loopData$comparisonMetric[index] <- loopData$comparisonAngleMetric[index] * loopData$magnitudes[index]
}
View(loopData)
View(journeyOutput)
strsplit(journeyOutput,"_")
strsplit(journeyOutput)
strsplit(journeyOutput,split = "_")
strsplit(journeyOutput$journeyID,split = "_")
apply(strsplit(journeyOutput$journeyID,split = "_"),"]")
unlist(strsplit(journeyOutput$journeyID,split = "_"))
sapply(journeyOutput$journeyID,'[', 1)
sapply(strsplit(journeyOutput$journeyID,split = "_"),'[', 1)
journeyOutput$start <- sapply(strsplit(journeyOutput$journeyID,split = "_"),'[', 1)
journeyOutput$end <- sapply(strsplit(journeyOutput$journeyID,split = "_"),'[', 2)
dist_mat <- dcast(dist_long, site1 ~ site2, value.var = "distance")
View(journeyOutput)
?dcast
??dcast
library(magrittr)
?dcast
install.packages('maditr')
?cast
?cast
?dcast
??dcast
?>cast
?cast
??cast
install.packages(maditr)
install.packages("maditr")
library("maditr")
?dcast
View(journeyOutput)
test <- dcast(journeyOutput,OceanographicResistance~start+end)
View(test)
test <- dcast(journeyOutput,start+end)
test <- dcast(journeyOutput,start~end)
test <- dcast(journeyOutput,start~end,value.var = "OceanographicResistance")
View(test)
View(test)
JourneyMatrix <- dcast(journeyOutput,start~end,value.var = "OceanographicResistance")
View(JourneyMatrix)
rownames(JourneyMatrix) <- JourneyMatrix$start
View(JourneyMatrix)
JourneyMatrix2 <- as.matrix(JourneyMatrix[,2:24])
View(JourneyMatrix2)
rownames(JourneyMatrix2) <- JourneyMatrix$start
library(vegan)
test <- metaMDS(JourneyMatrix2)
?metaMDS
View(journeyOutput)
write.csv(JourneyMatrix2,"OceanogrphicResistanceMatrix.csv")
write.csv(journeyOutput,"OceanogrphicResistancePairwise.csv")
