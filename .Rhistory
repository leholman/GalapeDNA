## add in the text to see sites
par(mar=c(2.1, 2.1, 2.1, 2.1))
nMDS <- metaMDS(vegdist(t(fishdat),method="jaccard",binary=TRUE),trymax=500)
plot(nMDS$points[,1],nMDS$points[,2],
pch=16,
cex=1.5,
col=metadatSites$col[match(sites,metadatSites$SiteID)],
main="",
ylab="",xlab="")
ordihull(nMDS,groups = sites,col = "grey71",draw = "polygon",lty=0)
points(nMDS$points[,1],nMDS$points[,2],pch=16,cex=1.5,
col=metadatSites$col[match(sites,metadatSites$SiteID)])
text(nMDS$points[,1],nMDS$points[,2]+0.05,labels=colnames(fishdat),cex=0.3)
####====5.0 Linking to Oceanography ====####
## Can we link biodiversity patterns to particle release parameters?
# Let's subset the data to take only the -3 day data & match it up with the correct order of sites
particle3 <- particle[particle$day=="-2",]
particle3o <- particle3[match(fishAlpha$ID,particle3$site),]
# Lets run linear models to test for individual effects
summary(lm(fishAlpha$Richness~particle3o$mean_spread))
summary(lm(fishAlpha$Richness~particle3o$ave_dist))
summary(lm(fishAlpha$Richness~particle3o$area..km.))
summary(lm(fishAlpha$Richness~particle3o$mean_dist))
#joint model
summary(lm(fishAlpha$Richness~particle3o$mean_spread+
particle3o$ave_dist+
particle3o$area..km.+
particle3o$mean_dist))
# Now beta diversity with a distance based redundancy analysis
m1 <- dbrda(vegdist(t(fishdatSite),method="jaccard",binary=TRUE)~particle3o$mean_spread+
particle3o$ave_dist+
particle3o$area..km.+
particle3o$mean_dist)
plot(m1)
anova(m1,permutations = 10000)
anova(m1,by="margin",permutations = 10000)
RsquareAdj(m1)
# Let's start with alpha diversity
pdf("figures/FishRichnessToOceanography.pdf",width =9,height=7)
par(mfrow=c(2,2))
par(mar=c(4.1, 4.1, 2.1, 1.1))
plot(particle3o$mean_spread,
fishAlpha$Richness,
ylab="ASV Richness",
xlab="Average Spread of Particles from Mean (km)",
col=metadatSites$col[match(fishAlpha$ID,metadatSites$SiteID)],pch=16,cex=2.5)
plot(particle3o$mean_dist,
fishAlpha$Richness,
ylab="ASV Richness",
xlab="Distance of Particle Centroid from Sampling Site (km)",
col=metadatSites$col[match(fishAlpha$ID,metadatSites$SiteID)],pch=16,cex=2.5)
plot(particle3o$area..km.,
fishAlpha$Richness,
ylab="ASV Richness",
xlab="Surface Area of Particles (km)",
col=metadatSites$col[match(fishAlpha$ID,metadatSites$SiteID)],pch=16,cex=2.5)
plot(particle3o$ave_dist,
fishAlpha$Richness,
ylab="ASV Richness",
xlab="Average Distance of Particles From Sampling Point (km)",
col=metadatSites$col[match(fishAlpha$ID,metadatSites$SiteID)],pch=16,cex=2.5)
dev.off()
### Now beta dissimilarity
#first lets pull in the data and melt it into pairwise observations
geographicDistance.pair <- reshape2::melt(as.matrix(read.csv("distanceData/SiteDistanceMatrix.csv",row.names = 1)),varnames = c("Start","End"))
oceanResistance.pair <- reshape2::melt(as.matrix(read.csv("distanceData/OceanogrphicResistanceMatrix.csv",row.names = 1)),varnames = c("Start","End"))
geographicDistance.pair.No0 <- geographicDistance.pair[-which(geographicDistance.pair$value == 0),]
oceanResistance.pair.No0 <- oceanResistance.pair[-which(geographicDistance.pair$value == 0),]
eDNAdistance.pair.mod = reshape2::melt(myjac_mod(fishdatSite), varnames=c("Start","End"))
eDNAdistance.pair.mod.No0 <- eDNAdistance.pair.mod[-which(eDNAdistance.pair.mod$value == 0),]
#now lets build some models
model1 = lm (eDNAdistance.pair.mod.No0$value~geographicDistance.pair.No0$value)
model2 = lm (eDNAdistance.pair.mod.No0$value~oceanResistance.pair.No0$value)
model3 = lm (model1$residuals ~ oceanResistance.pair.No0$value)
model4 = lm (eDNAdistance.pair.mod.No0$value~geographicDistance.pair.No0$value + oceanResistance.pair.No0$value)
sink("statisticsReports/lmOceanGeo.txt")
summary(model1)
summary(model2)
summary(model3)
summary(model4)
sink()
install.packages("heplots")
library(heplots)
?etasq
etasq(model4)
etasq(model1)
etasq(model2)
etasq(model3)
etasq(model4)
summary(model4)
summary(model1)
summary(model2)
summary(model3)
summary(model4)
etasq(model4)
citation(heplots)
hist(oceanResistance.pair.No0$value)
hist(oceanResistance.pair.No0$value,breaks=100)
list.files(pattern=".*.csv","distanceData/pathPoints")
list.files(pattern=".*.csv","distanceData/pathPointsElNino/")
month <- list.files(pattern=".*.csv","distanceData/pathPointsElNino/")[1]
#month <- "pathPointsTable_Apr.csv"
monthText <- gsub(".csv","",gsub("pathPointsTable_","",month))
print(monthText)
modeldat <-read.csv(paste0("distanceData/pathPoints/pathPointsTable_",monthText,".csv"))
modeldat <-read.csv(paste0("distanceData/pathPointsElNino//pathPointsTable_",monthText,".csv"))
## 1 Calculate angle and magnitude of each lat lon point along the path
#angle
modeldat$resultantAngle <- unlist(mapply(vectorAngle,modeldat$UVEL,modeldat$VVEL))
#magnitude
modeldat$magnitudes <- unlist(mapply(vectorSum,modeldat$UVEL,modeldat$VVEL))
modeldat$journeyID <- paste(modeldat$Start,modeldat$End,sep="_")
journeyOutput <- data.frame("journeyID"=unique(paste(modeldat$Start,modeldat$End,sep="_")),"OceanographicResistance"=rep(0,length(unique(paste(modeldat$Start,modeldat$End,sep="_")))),"OceanographicResistanceSD"=rep(0,length(unique(paste(modeldat$Start,modeldat$End,sep="_")))))
for (journeyIndex in 1:length(journeyOutput$journeyID)){
# journeyIndex <- 8
loopJourney <- journeyOutput$journeyID[journeyIndex]
loopData <- modeldat[modeldat$journeyID==loopJourney,]
loopData$comparisonAngle <- NA
loopData$comparisonAngleDiff <- NA
loopData$comparisonAngleMetric <- NA
loopData$comparisonMetric <- NA
for (loopLocation in 1:length(loopData$Order)){
if(loopData$Order[loopLocation]==max(loopData$Order)){next()}
index <- match(loopData$Order[loopLocation],loopData$Order)
index2 <- match(loopData$Order[loopLocation+1],loopData$Order)
loopData$comparisonAngle[index] <- azimuth(loopData$lat[index],loopData$lon[index],loopData$lat[index2],loopData$lon[index2])
loopData$comparisonAngleDiff[index] <- angleCalc(loopData$comparisonAngle[index],loopData$resultantAngle[index])
loopData$comparisonAngleMetric[index] <- cosTrans(loopData$comparisonAngleDiff[index])
loopData$comparisonMetric[index] <- loopData$comparisonAngleMetric[index] * loopData$magnitudes[index]
}
journeyOutput$OceanographicResistance[journeyIndex] <-mean(loopData$comparisonMetric,na.rm = T)
journeyOutput$OceanographicResistanceSD[journeyIndex] <-sd(loopData$comparisonMetric,na.rm = T)
}
journeyOutput$start <- sapply(strsplit(journeyOutput$journeyID,split = "_"),'[', 1)
journeyOutput$end <- sapply(strsplit(journeyOutput$journeyID,split = "_"),'[', 2)
JourneyMatrix <- dcast(journeyOutput,start~end,value.var = "OceanographicResistance")
JourneyMatrix2 <- as.matrix(JourneyMatrix[,2:24])
rownames(JourneyMatrix2) <- JourneyMatrix$start
write.csv(JourneyMatrix2,paste0("distanceData/monthlyResistanceElNino/OceanogrphicResistanceMatrix_",monthText,".csv"))
write.csv(journeyOutput,paste0("distanceData/monthlyResistanceElNino/OceanogrphicResistancePairwise_",monthText,".csv"))
#month <- "pathPointsTable_Apr.csv"
monthText <- gsub(".csv","",gsub("pathPointsTable_","",month))
print(monthText)
modeldat <-read.csv(paste0("distanceData/pathPointsElNino//pathPointsTable_",monthText,".csv"))
View(modeldat)
## 1 Calculate angle and magnitude of each lat lon point along the path
#angle
modeldat$resultantAngle <- unlist(mapply(vectorAngle,modeldat$UVEL,modeldat$VVEL))
##Function 1 - calculate the resultant angle from a Northing and an Easting
vectorAngle <- function(Northing,Easting){
if(Northing == 0 & Easting == 0){return(0)}
Northing=Northing+0.0000001
Easting=Easting+0.0000001
resultant_angle <- atan2(sqrt(Northing^2),sqrt(Easting^2))
resultant_angle_degrees <- (180/pi) * resultant_angle
if(Northing>0 & Easting>0){return(90-resultant_angle_degrees)} else
if(Northing<0 & Easting>0){return(90+resultant_angle_degrees)} else
if(Northing<0 & Easting<0){return(270-resultant_angle_degrees)} else
if(Northing>0 & Easting<0){return(270+resultant_angle_degrees)}
}
#resultant_angle_degrees <- ifelse(resultant_angle_degrees < 0, 360 + resultant_angle_degrees, resultant_angle_degrees)
#return(resultant_angle_degrees)}
#testing
vectorAngle(5,5)
vectorAngle(-5,5)
vectorAngle(-5,-5)
vectorAngle(5,-5)
##Function 2 Calculate a resultant magnitude of the vector from a Northign and an Easting
vectorSum <- function(Northing,Easting){
if(Northing == 0 & Easting == 0){return(NA)}
resultantMagnitude <- sqrt(Northing^2+Easting^2)
return(resultantMagnitude)}
modeldat$magnitudes <- unlist(mapply(vectorSum,modeldat$UVEL,modeldat$VVEL))
##Function 3 Calculate a the angle (azimuth) between two geographic points with lat lon
azimuth <- function(lat1, lon1, lat2, lon2) {
# Convert decimal degrees to radians
lat1 <- lat1 * pi / 180
lon1 <- lon1 * pi / 180
lat2 <- lat2 * pi / 180
lon2 <- lon2 * pi / 180
# Calculate the difference in longitude
delta_lon <- lon2 - lon1
# Calculate the azimuth (bearing) using the Haversine formula
y <- sin(delta_lon) * cos(lat2)
x <- cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(delta_lon)
azimuth_rad <- atan2(y, x)
# Convert radians to degrees
azimuth_deg <- azimuth_rad * 180 / pi
# Make sure the result is in the range [0, 360)
if (azimuth_deg < 0) {
azimuth_deg <- azimuth_deg + 360
}
return(azimuth_deg)
}
#testing
azimuth(55.68517608483797, 12.57629649327822,55.66184699523609, 12.57955805920173)
##Function 4 Calculate the azimuth difference from angle A to angle B
angleCalc <- function(A,B){
input <- B - A
if (input > 0){
return(input)} else
if (input < 0) {
return(input+360)} else
if (input == 0){return(0)}
}
##Function 5 scale an azimuth angle into resistance with 1 being 0 degrees and -1 being 180 degrees
cosTrans <- function(input){
return(cos((input/360)*(2*pi)))
}
for (month in list.files(pattern=".*.csv","distanceData/pathPointsElNino/")){
#month <- "pathPointsTable_Apr.csv"
monthText <- gsub(".csv","",gsub("pathPointsTable_","",month))
print(monthText)
modeldat <-read.csv(paste0("distanceData/pathPointsElNino//pathPointsTable_",monthText,".csv"))
## 1 Calculate angle and magnitude of each lat lon point along the path
#angle
modeldat$resultantAngle <- unlist(mapply(vectorAngle,modeldat$UVEL,modeldat$VVEL))
#magnitude
modeldat$magnitudes <- unlist(mapply(vectorSum,modeldat$UVEL,modeldat$VVEL))
## 2 Create an output dataframe for each journey
modeldat$journeyID <- paste(modeldat$Start,modeldat$End,sep="_")
journeyOutput <- data.frame("journeyID"=unique(paste(modeldat$Start,modeldat$End,sep="_")),"OceanographicResistance"=rep(0,length(unique(paste(modeldat$Start,modeldat$End,sep="_")))),"OceanographicResistanceSD"=rep(0,length(unique(paste(modeldat$Start,modeldat$End,sep="_")))))
## 3 loop over each journey
for (journeyIndex in 1:length(journeyOutput$journeyID)){
# journeyIndex <- 8
loopJourney <- journeyOutput$journeyID[journeyIndex]
loopData <- modeldat[modeldat$journeyID==loopJourney,]
loopData$comparisonAngle <- NA
loopData$comparisonAngleDiff <- NA
loopData$comparisonAngleMetric <- NA
loopData$comparisonMetric <- NA
for (loopLocation in 1:length(loopData$Order)){
if(loopData$Order[loopLocation]==max(loopData$Order)){next()}
index <- match(loopData$Order[loopLocation],loopData$Order)
index2 <- match(loopData$Order[loopLocation+1],loopData$Order)
loopData$comparisonAngle[index] <- azimuth(loopData$lat[index],loopData$lon[index],loopData$lat[index2],loopData$lon[index2])
loopData$comparisonAngleDiff[index] <- angleCalc(loopData$comparisonAngle[index],loopData$resultantAngle[index])
loopData$comparisonAngleMetric[index] <- cosTrans(loopData$comparisonAngleDiff[index])
loopData$comparisonMetric[index] <- loopData$comparisonAngleMetric[index] * loopData$magnitudes[index]
}
journeyOutput$OceanographicResistance[journeyIndex] <-mean(loopData$comparisonMetric,na.rm = T)
journeyOutput$OceanographicResistanceSD[journeyIndex] <-sd(loopData$comparisonMetric,na.rm = T)
}
#Now lets transform and output the data
journeyOutput$start <- sapply(strsplit(journeyOutput$journeyID,split = "_"),'[', 1)
journeyOutput$end <- sapply(strsplit(journeyOutput$journeyID,split = "_"),'[', 2)
JourneyMatrix <- dcast(journeyOutput,start~end,value.var = "OceanographicResistance")
JourneyMatrix2 <- as.matrix(JourneyMatrix[,2:24])
rownames(JourneyMatrix2) <- JourneyMatrix$start
write.csv(JourneyMatrix2,paste0("distanceData/monthlyResistanceElNino/OceanogrphicResistanceMatrix_",monthText,".csv"))
write.csv(journeyOutput,paste0("distanceData/monthlyResistanceElNino/OceanogrphicResistancePairwise_",monthText,".csv"))
}
par(mfrow=c(4,3))
ResistanceMonths <- as.list(c())
par(mfrow=c(4,3))
ResistanceMonths <- as.list(c())
ResistanceMonths <- as.list(c())
for (month in list.files(pattern="OceanogrphicResistanceMatrix.*","distanceData/monthlyResistanceElNino/")){
oceanResistance <- as.dist(as.matrix(read.csv(paste0("distanceData/monthlyResistance/",month),row.names = 1)))
nMDS.resist <- metaMDS(oceanResistance,trymax=500)
plot(nMDS.resist,type = "t",main="Resistance")
ResistanceMonths <- append(ResistanceMonths,list(as.matrix(oceanResistance)))
}
list.files(pattern="OceanogrphicResistanceMatrix.*","distanceData/monthlyResistanceElNino/")
par(mfrow=c(4,3))
ResistanceMonths <- as.list(c())
for (month in list.files(pattern="OceanogrphicResistanceMatrix.*","distanceData/monthlyResistanceElNino/")){
oceanResistance <- as.dist(as.matrix(read.csv(paste0("distanceData/monthlyResistanceElNino//",month),row.names = 1)))
nMDS.resist <- metaMDS(oceanResistance,trymax=500)
plot(nMDS.resist,type = "t",main="Resistance")
ResistanceMonths <- append(ResistanceMonths,list(as.matrix(oceanResistance)))
}
par(mfrow=c(4,3))
ResistanceMonths <- as.list(c())
for (month in list.files(pattern="OceanogrphicResistanceMatrix.*","distanceData/monthlyResistance/")){
oceanResistance <- as.dist(as.matrix(read.csv(paste0("distanceData/monthlyResistance/",month),row.names = 1)))
nMDS.resist <- metaMDS(oceanResistance,trymax=500)
plot(nMDS.resist,type = "t",main="Resistance")
ResistanceMonths <- append(ResistanceMonths,list(as.matrix(oceanResistance)))
}
# Load packages
library(ncdf4)
library(raster)
##Lots of lines hashed out here, original file is 10GB+ so only subset used ;)
#load GEBCO_2022 netcdf downloaded on 110822 - https://www.gebco.net/data_and_products/gridded_bathymetry_data/
#gebco <- raster("mapBuilding/GEBCO_2022_sub_ice_topo.nc")
# Create extent (our map area)
#galap.ex <- extent(-92, -89, -1.55, 0.68)
# Create a crop of the bathymetric data
#gebco.crop <- crop(gebco, galap.ex)
#Save file
#saveRDS(gebco.crop,file="mapBuilding/GalapBathy.rds")
gebco.crop <- readRDS("mapBuilding/GalapBathy.rds")
#load lat lon
metadata <- read.csv(file = "metadata.site.out.csv")
#function to calculate break points for colours from https://www.benjaminbell.co.uk/2019/08/bathymetric-maps-in-r-colour-palettes.html
## x = raster, b1 & b2 = number of divisions for each sequence, r1 & r2 = rounding value
colbr <- function(x, b1=50, b2=50, r1=-2, r2=-2) {
# Min/max values of the raster (x)
mi <- cellStats(x, stat="min")-100
ma <- cellStats(x, stat="max")+100
# Create sequences, but only use unique numbers
s1 <- unique(round(seq(mi, 0, 0-mi/b1),r1))
s2 <- unique(round(seq(0, ma, ma/b2),r2))
# Combine sequence for our break points, removing duplicate 0
s3 <- c(s1, s2[-1])
# Create a list with the outputs
# [[1]] = length of the first sequence minus 1 (water)
# [[2]] = length of the second sequence minus 1 (land)
# [[3]] = The break points
x <- list(length(s1)-1, length(s2)-1, s3)
}
galap.br <- colbr(gebco.crop,b2=1)
# Get country shapefiles
eq <- getData("GADM", country="ECU", level=0)
# Colour palette
blue.col <- colorRampPalette(c("darkblue", "lightblue"))
#First plot
pdf(width = 8,height=6.5,file="mapBuilding/test1.pdf")
plot(gebco.crop, col=c(blue.col(galap.br[[1]]), grey.colors(galap.br[[2]])), breaks=galap.br[[3]],axes = FALSE,box=F,legend=F)
#-92, -89, -1.55, 0.68)
axis(1,
at=pretty(c(-92, -89)),
labels = parse(text=degreeLabelsEW(pretty(c(-92, -89)))))
axis(2,
at=pretty(c(-1.55, 0.68)),
labels = parse(text=degreeLabelsNS(pretty(c(-1.55, 0.68)))),las=TRUE)
#plot(eq, add=TRUE)
points(metadata$lon2,metadata$lat2,pch=16, col='black',cex=1)
points(metadata$lon2,metadata$lat2,pch=16, col='white',cex=0.5)
dev.off()
#Adding in colours per island
cols <- c("#80B1D3","#FFFFB3","#FFFFB3","#80B1D3","#FB8072","#BEBADA","#FFED6F","#CCEBC5",
"#80B1D3","#8DD3C7","#FDB462","#FFFFB3","#B3DE69","gray85","#FFFFB3","#80B1D3",
"#FCCDE5","#80B1D3","#80B1D3","#CCEBC5","#BC80BD","#8DD3C7","#80B1D3")
##Make a colour index so each ecoregion-island has a different colour
SEasternCols <- colorRampPalette(c("#D55E00","#E69F00","#faf6c1"))
#NorthernCols <-colorRampPalette(c("#0072B2","#56B4E9"))
NorthernCols <-colorRampPalette(c("#003e60","#56B4E9"))
ElizCols <- colorRampPalette(c("#CC79A7","#762d55"))
WesternCols <- colorRampPalette(c("#009E73","#004935"))
AllCols <- c(SEasternCols(8),ElizCols(2),NorthernCols(4),WesternCols(2))
ColIndex <- data.frame("EcoIsland"=sort(unique(paste0(metadata$EcoRegion,"-",metadata$island))),
"Colour"=AllCols)
ColIndex$Colour[match(paste0(metadata$EcoRegion,"-",metadata$island),ColIndex$EcoIsland)]
pdf(width = 8,height=6.35,file="mapBuilding/mapV1.pdf")
plot(gebco.crop, col=c(blue.col(galap.br[[1]]), grey.colors(galap.br[[2]])), breaks=galap.br[[3]],axes = FALSE,box=F,legend=F)
#plot(eq, add=TRUE)
points(metadata$lon2,metadata$lat2,pch=16, col='white',cex=2.5)
points(metadata$lon2,metadata$lat2,pch=16, col=ColIndex$Colour[match(paste0(metadata$EcoRegion,"-",metadata$island),ColIndex$EcoIsland)]
,cex=2)
axis(1,
at=pretty(c(-92, -89)),
labels = parse(text=degreeLabelsEW(pretty(c(-92, -89)))),lwd = 0, lwd.ticks = 1)
axis(2,
at=pretty(c(-1.55, 0.68)),
labels = parse(text=degreeLabelsNS(pretty(c(-1.55, 0.68)))),las=TRUE,lwd = 0, lwd.ticks = 1)
#The legend editing for raster layers sucks, the below is a very hacky stupid way to get things to look right, buyer beware.
gebco.crop.mod <- gebco.crop
gebco.crop.mod@data@max<- 1
gebco.crop.mod@data@values[gebco.crop.mod@data@values>0] <- 1
plot(gebco.crop.mod, legend.only=TRUE, col=c(blue.col(galap.br[[1]]+1), grey.colors(galap.br[[2]])),breaks=c(galap.br[[3]][1:43],1),
legend.width=1, legend.shrink=0.75,font=2, line=2.5, cex=0.8,
axis.args=list( at=pretty(c(galap.br[[3]][1:43],1)), labels=pretty(c(galap.br[[3]][1:43],1))))
dev.off()
### playground basement
plot(gebco.crop, col=c(blue.col(galap.br[[1]]), grey.colors(galap.br[[2]])), breaks=galap.br[[3]],axes = FALSE,box=F,legend = FALSE)
#plot(eq, add=TRUE)
#plot(eq, add=TRUE)
points(metadata$lon2,metadata$lat2,pch=16, col='black',cex=1)
points(metadata$lon2,metadata$lat2,pch=16, col='white',cex=0.5)
text(metadata$lon2,metadata$lat2+0.08,labels=metadata$SiteID,cex=0.5,col="green")
site <- "RED"
site <- "SUAR"
points(pathPointsTable$lon[pathPointsTable$Start==site],
pathPointsTable$lat[pathPointsTable$Start==site],
col="lightgreen",
pch=16,
cex=0.2)
#calculate some distances 'as-the-fish-swims'
####====0.0 Packages====####
library('gdistance')
library('sf')
library('geosphere')
library("maditr")
####====1.0 As-the-fish-swims Distance & Points  ====####
#Pull in galapagos
gebco.crop <- readRDS("mapBuilding/GalapBathy.rds")
gebco.crop2 <- gebco.crop
#set land to zero, sea to 1
gebco.crop2@data@values[gebco.crop2@data@values>-1] <-0
gebco.crop2@data@values[gebco.crop2@data@values<0] <-Inf
#Places
metadatSites <- read.csv("metadata.site.out.csv",row.names=1)
places <- cbind(metadatSites$lon2,metadatSites$lat2)
sitePairwiseDist <- expand.grid(Start=metadatSites$SiteID,
End=metadatSites$SiteID)
#
tr1 <- transition(gebco.crop2, transitionFunction=mean, directions=16)
tr2 <- geoCorrection(tr1, type="r", multpl=TRUE)
sitePairwiseDist$Flat <- metadatSites$lat2[match(sitePairwiseDist$Start,metadatSites$SiteID)]
sitePairwiseDist$Flon <- metadatSites$lon2[match(sitePairwiseDist$Start,metadatSites$SiteID)]
sitePairwiseDist$Tlat <- metadatSites$lat2[match(sitePairwiseDist$End,metadatSites$SiteID)]
sitePairwiseDist$Tlon <- metadatSites$lon2[match(sitePairwiseDist$End,metadatSites$SiteID)]
sitePairwiseDist$Calcdistance <- rep(NA,length(sitePairwiseDist$End))
#empty points table
pathPointsTable <- c()
#Loop over site comparisons and output needed data
for (row in 1:length(sitePairwiseDist$End)){
#set dist to zero and skip loop for comparing a site to itself
if(sitePairwiseDist$Start[row]==sitePairwiseDist$End[row]){sitePairwiseDist$Calcdistance[row] <- 0
next()}
#get the shortest path
loopPath <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
#calculate the distance of the shortest path
looplen <- lengthLine(loopPath)
#sample points along the path every 1000 metres
loopPathpoints <- spsample(loopPath,looplen/1000,type="regular")
#output lengths to dataframe
sitePairwiseDist$Calcdistance[row] <- looplen
#create point output table
loopPathPointsize <- length(loopPathpoints)
loopPointsTable <- data.frame("Order"=1:loopPathPointsize,
"Start"=rep(sitePairwiseDist$Start[row],loopPathPointsize),
"End"=rep(sitePairwiseDist$End[row],loopPathPointsize),
"lon"=loopPathpoints@coords[,1],
"lat"=loopPathpoints@coords[,2])
pathPointsTable <- rbind(pathPointsTable,loopPointsTable)
print(row)
}
sitePairwiseDist.d <- dcast(sitePairwiseDist,Start~End,value.var = "Calcdistance")
sitePairwiseDist.d.out <- as.matrix(sitePairwiseDist.d[,2:24])
rownames(sitePairwiseDist.d.out) <- sitePairwiseDist.d$Start
warnings()
### playground basement
plot(gebco.crop, col=c(blue.col(galap.br[[1]]), grey.colors(galap.br[[2]])), breaks=galap.br[[3]],axes = FALSE,box=F,legend = FALSE)
#plot(eq, add=TRUE)
points(metadata$lon2,metadata$lat2,pch=16, col='black',cex=1)
points(metadata$lon2,metadata$lat2,pch=16, col='white',cex=0.5)
points(pathPointsTable$lon[pathPointsTable$Start==site],
pathPointsTable$lat[pathPointsTable$Start==site],
col="lightgreen",
pch=16,
cex=0.2)
### playground basement
plot(gebco.crop, col=c(blue.col(galap.br[[1]]), grey.colors(galap.br[[2]])), breaks=galap.br[[3]],axes = FALSE,box=F,legend = FALSE)
#plot(eq, add=TRUE)
points(metadata$lon2,metadata$lat2,pch=16, col='black',cex=1)
points(metadata$lon2,metadata$lat2,pch=16, col='white',cex=0.5)
points(pathPointsTable$lon[pathPointsTable$Start==site],
pathPointsTable$lat[pathPointsTable$Start==site],
col="darkred",
pch=16,
cex=0.2)
site <- "RED"
points(pathPointsTable$lon[pathPointsTable$Start==site],
pathPointsTable$lat[pathPointsTable$Start==site],
col="darkred",
pch=16,
cex=0.2)
### playground basement
plot(gebco.crop, col=c(blue.col(galap.br[[1]]), grey.colors(galap.br[[2]])), breaks=galap.br[[3]],axes = FALSE,box=F,legend = FALSE)
#plot(eq, add=TRUE)
points(metadata$lon2,metadata$lat2,pch=16, col='black',cex=1)
points(metadata$lon2,metadata$lat2,pch=16, col='white',cex=0.5)
points(pathPointsTable$lon[pathPointsTable$Start==site],
pathPointsTable$lat[pathPointsTable$Start==site],
col="darkred",
pch=16,
cex=0.2)
pdf("mapBuilding/example.pdf",width=7,height=5)
points(pathPointsTable$lon[pathPointsTable$Start==site],
pathPointsTable$lat[pathPointsTable$Start==site],
col="darkred",
pch=16,
cex=0.2)
dev.off()
dev.off()
pdf("mapBuilding/example.pdf",width=7,height=5)
points(pathPointsTable$lon[pathPointsTable$Start==site],
pathPointsTable$lat[pathPointsTable$Start==site],
col="darkred",
pch=16,
cex=0.2)
dev.off()
pdf("mapBuilding/example.pdf",width=7,height=5)
points(pathPointsTable$lon[pathPointsTable$Start==site],
pathPointsTable$lat[pathPointsTable$Start==site],
col="darkred",
pch=16,
cex=0.2)
pdf("mapBuilding/example.pdf",width=7,height=5)
plot(gebco.crop, col=c(blue.col(galap.br[[1]]), grey.colors(galap.br[[2]])), breaks=galap.br[[3]],axes = FALSE,box=F,legend = FALSE)
points(pathPointsTable$lon[pathPointsTable$Start==site],
pathPointsTable$lat[pathPointsTable$Start==site],
col="darkred",
pch=16,
cex=0.2)
dev.off()
pdf("mapBuilding/example.pdf",width=7,height=5)
plot(gebco.crop, col=c(blue.col(galap.br[[1]]), grey.colors(galap.br[[2]])), breaks=galap.br[[3]],axes = FALSE,box=F,legend = FALSE)
points(metadata$lon2,metadata$lat2,pch=16, col='black',cex=1)
points(metadata$lon2,metadata$lat2,pch=16, col='white',cex=0.5)
points(pathPointsTable$lon[pathPointsTable$Start==site],
pathPointsTable$lat[pathPointsTable$Start==site],
col="darkred",
pch=16,
cex=0.2)
dev.off()
