library(raster)
install.packages("ncdf4","raster")
# Load packages
library(ncdf4)
library(raster)
install.packages(raster")
""
install.packages("raster")
install.packages("raster")
library(raster)
# Load packages
library(ncdf4)
gwtwd
getwd
getwd()
setwd("GitHubRepos/GalapeDNA/")
#load GEBCO_2022 netcdf downloaded on 110822 - https://www.gebco.net/data_and_products/gridded_bathymetry_data/
gebco <- raster("mapBuilding/gebco_2022_sub_ice_topo/GEBCO_2022_sub_ice_topo.nc")
plot(gebco)
nc_open("GEBCO_2019.nc")
nc_open("mapBuilding/gebco_2022_sub_ice_topo/GEBCO_2022_sub_ice_topo.nc")
?getData
?extent
# Create extent (our map area)
galap.ex <- extent(-92.145, -88.1749, -1.8196, 1.8677)
# Create a crop of the bathymetric data
gebco.crop <- crop(gebco, galap.ex)
plot(gebco.crop)
#function from https://www.benjaminbell.co.uk/2019/08/bathymetric-maps-in-r-colour-palettes.html
colbr <- function(x, b1=50, b2=50, r1=-2, r2=-2) {
# Min/max values of the raster (x)
mi <- cellStats(x, stat="min")-100
ma <- cellStats(x, stat="max")+100
# Create sequences, but only use unique numbers
s1 <- unique(round(seq(mi, 0, 0-mi/b1),r1))
s2 <- unique(round(seq(0, ma, ma/b2),r2))
# Combine sequence for our break points, removing duplicate 0
s3 <- c(s1, s2[-1])
# Create a list with the outputs
# [[1]] = length of the first sequence minus 1 (water)
# [[2]] = length of the second sequence minus 1 (land)
# [[3]] = The break points
x <- list(length(s1)-1, length(s2)-1, s3)
}
pr.br <- colbr(gebco.crop)
pr.br
pr.br <- colbr(gebco.crop,b2=100)
pr.br
pr.br <- colbr(gebco.crop,b2=4)
pr.br
?getData()
library("metabarTOAD")
library("vegan")
library("Biostrings")
library("RColorBrewer")
library("seqinr")
library("sp")
#### Settings and Setup####
##Get metadata
metadat <- read.csv("metadata.csv")
metadat.site <- read.csv("metadata.site.csv")
#Set some variables
minreads <- 3
items <- NULL
#Set the seed
set.seed("123456")
palette(brewer.pal(12, "Set3"))
View(metadat.site)
substr(metadat.site$latitude,3,4)
substr(metadat.site$latitude,1,2)
substr(metadat.site$latitude,1,1)
ifelse(substr(metadat.site$latitude,1,1)="S","-","")
ifelse(substr(metadat.site$latitude,1,1)=="S","-","")
metadat.site$lat2 <- as.numeric(paste0(ifelse(substr(metadat.site$latitude,1,1)=="S","-",""),substr(metadat.site$latitude,3,4),".",substr(as.character(as.numeric(paste0(substr(metadat.site$latitude,6,7),".",substr(metadat.site$latitude,9,11)))/60),3,20)))
metadat.site$lon2 <- as.numeric(paste0(ifelse(substr(metadat.site$latitude,1,1)=="S","-",""),substr(metadat.site$longitude,4,5),".",substr(as.character(as.numeric(paste0(substr(metadat.site$longitude,8,9),".",substr(metadat.site$longitude,11,13)))/60),3,20)))
View(metadat.site)
metadat.site$lat2 <- as.numeric(paste0(ifelse(substr(metadat.site$latitude,1,1)=="S","-",""),substr(metadat.site$latitude,3,4),".",substr(as.character(as.numeric(paste0(substr(metadat.site$latitude,6,7),".",substr(metadat.site$latitude,9,11)))/60),3,20)))
metadat.site$lon2 <- as.numeric(paste0(ifelse(substr(metadat.site$latitude,1,1)=="W","-",""),substr(metadat.site$longitude,4,5),".",substr(as.character(as.numeric(paste0(substr(metadat.site$longitude,8,9),".",substr(metadat.site$longitude,11,13)))/60),3,20)))
View(metadat.site)
metadat.site$lat2 <- as.numeric(paste0(ifelse(substr(metadat.site$latitude,1,1)=="S","-",""),substr(metadat.site$latitude,3,4),".",substr(as.character(as.numeric(paste0(substr(metadat.site$latitude,6,7),".",substr(metadat.site$latitude,9,11)))/60),3,20)))
metadat.site$lon2 <- as.numeric(paste0(ifelse(substr(metadat.site$longitude,1,1)=="W","-",""),substr(metadat.site$longitude,4,5),".",substr(as.character(as.numeric(paste0(substr(metadat.site$longitude,8,9),".",substr(metadat.site$longitude,11,13)))/60),3,20)))
View(metadat.site)
metadat.site$lat2 <- as.numeric(paste0(ifelse(substr(metadat.site$latitude,1,1)=="S","-",""),substr(metadat.site$latitude,3,4),".",substr(as.character(as.numeric(paste0(substr(metadat.site$latitude,6,7),".",substr(metadat.site$latitude,9,11)))/60),3,20)))
metadat.site$lon2 <- as.numeric(paste0(ifelse(substr(metadat.site$longitude,1,1)=="W","-",""),substr(metadat.site$longitude,4,5),".",substr(as.character(as.numeric(paste0(substr(metadat.site$longitude,8,9),".",substr(metadat.site$longitude,11,13)))/60),3,20)))
write.csv(metadat,file = "metadata.site.out.csv")
kages
# Load packages
library(ncdf4)
library(raster)
##Lots of lines hashed out here, original file is 10GB+ so only subset used ;)
#load GEBCO_2022 netcdf downloaded on 110822 - https://www.gebco.net/data_and_products/gridded_bathymetry_data/
#gebco <- raster("mapBuilding/gebco_2022_sub_ice_topo/GEBCO_2022_sub_ice_topo.nc")
# Create extent (our map area)
#galap.ex <- extent(-92, -89, -1.55, 0.5)
# Create a crop of the bathymetric data
#gebco.crop <- crop(gebco, galap.ex)
#Save file
#saveRDS(gebco.crop,file="mapBuilding/GalapBathy.rds")
gebco.crop <- readRDS("mapBuilding/GalapBathy.rds")
#load lat lon
metadata <- read.csv(file = "metadata.site.out.csv")
#function to calculate break points for colours from https://www.benjaminbell.co.uk/2019/08/bathymetric-maps-in-r-colour-palettes.html
## x = raster, b1 & b2 = number of divisions for each sequence, r1 & r2 = rounding value
colbr <- function(x, b1=50, b2=50, r1=-2, r2=-2) {
# Min/max values of the raster (x)
mi <- cellStats(x, stat="min")-100
ma <- cellStats(x, stat="max")+100
# Create sequences, but only use unique numbers
s1 <- unique(round(seq(mi, 0, 0-mi/b1),r1))
s2 <- unique(round(seq(0, ma, ma/b2),r2))
# Combine sequence for our break points, removing duplicate 0
s3 <- c(s1, s2[-1])
# Create a list with the outputs
# [[1]] = length of the first sequence minus 1 (water)
# [[2]] = length of the second sequence minus 1 (land)
# [[3]] = The break points
x <- list(length(s1)-1, length(s2)-1, s3)
}
galap.br <- colbr(gebco.crop,b2=1)
# Get country shapefiles
eq <- getData("GADM", country="ECU", level=0)
# Colour palette
blue.col <- colorRampPalette(c("darkblue", "lightblue"))
#First plot
pdf(width = 8,height=6.5,file="mapBuilding/test.pdf")
plot(gebco.crop, col=c(blue.col(galap.br[[1]]), grey.colors(galap.br[[2]])), breaks=galap.br[[3]],axes = FALSE,box=F,legend = FALSE)
#plot(eq, add=TRUE)
points(metadata$lon2,metadata$lat2,pch=16, col='black',cex=1)
points(metadata$lon2,metadata$lat2,pch=16, col='white',cex=0.5)
dev.off()
#load lat lon
metadata <- read.csv(file = "metadata.site.out.csv")
View(metadata)
View(metadata)
#load lat lon
metadata <- read.csv(file = "metadata.site.out.csv")
View(metadat.site)
write.csv(metadat.site,file = "metadata.site.out.csv")
#load lat lon
metadata <- read.csv(file = "metadata.site.out.csv")
gebco.crop <- readRDS("mapBuilding/GalapBathy.rds")
#load lat lon
metadata <- read.csv(file = "metadata.site.out.csv")
#function to calculate break points for colours from https://www.benjaminbell.co.uk/2019/08/bathymetric-maps-in-r-colour-palettes.html
## x = raster, b1 & b2 = number of divisions for each sequence, r1 & r2 = rounding value
colbr <- function(x, b1=50, b2=50, r1=-2, r2=-2) {
# Min/max values of the raster (x)
mi <- cellStats(x, stat="min")-100
ma <- cellStats(x, stat="max")+100
# Create sequences, but only use unique numbers
s1 <- unique(round(seq(mi, 0, 0-mi/b1),r1))
s2 <- unique(round(seq(0, ma, ma/b2),r2))
# Combine sequence for our break points, removing duplicate 0
s3 <- c(s1, s2[-1])
# Create a list with the outputs
# [[1]] = length of the first sequence minus 1 (water)
# [[2]] = length of the second sequence minus 1 (land)
# [[3]] = The break points
x <- list(length(s1)-1, length(s2)-1, s3)
}
galap.br <- colbr(gebco.crop,b2=1)
# Get country shapefiles
eq <- getData("GADM", country="ECU", level=0)
# Colour palette
blue.col <- colorRampPalette(c("darkblue", "lightblue"))
#First plot
pdf(width = 8,height=6.5,file="mapBuilding/test.pdf")
plot(gebco.crop, col=c(blue.col(galap.br[[1]]), grey.colors(galap.br[[2]])), breaks=galap.br[[3]],axes = FALSE,box=F,legend = FALSE)
#plot(eq, add=TRUE)
points(metadata$lon2,metadata$lat2,pch=16, col='black',cex=1)
points(metadata$lon2,metadata$lat2,pch=16, col='white',cex=0.5)
dev.off()
View(metadat.site)
##Lots of lines hashed out here, original file is 10GB+ so only subset used ;)
#load GEBCO_2022 netcdf downloaded on 110822 - https://www.gebco.net/data_and_products/gridded_bathymetry_data/
gebco <- raster("mapBuilding/gebco_2022_sub_ice_topo/GEBCO_2022_sub_ice_topo.nc")
##Lots of lines hashed out here, original file is 10GB+ so only subset used ;)
#load GEBCO_2022 netcdf downloaded on 110822 - https://www.gebco.net/data_and_products/gridded_bathymetry_data/
gebco <- raster("mapBuilding/gebco_2022_sub_ice_topo/GEBCO_2022_sub_ice_topo.nc")
##Lots of lines hashed out here, original file is 10GB+ so only subset used ;)
#load GEBCO_2022 netcdf downloaded on 110822 - https://www.gebco.net/data_and_products/gridded_bathymetry_data/
gebco <- raster("mapBuilding/GEBCO_2022_sub_ice_topo.nc")
##Lots of lines hashed out here, original file is 10GB+ so only subset used ;)
#load GEBCO_2022 netcdf downloaded on 110822 - https://www.gebco.net/data_and_products/gridded_bathymetry_data/
gebco <- raster("mapBuilding/GEBCO_2022_sub_ice_topo.nc")
# Create extent (our map area)
galap.ex <- extent(-92, -89, -1.55, 0.63)
# Create a crop of the bathymetric data
gebco.crop <- crop(gebco, galap.ex)
#Save file
saveRDS(gebco.crop,file="mapBuilding/GalapBathy.rds")
gebco.crop <- readRDS("mapBuilding/GalapBathy.rds")
#load lat lon
metadata <- read.csv(file = "metadata.site.out.csv")
#function to calculate break points for colours from https://www.benjaminbell.co.uk/2019/08/bathymetric-maps-in-r-colour-palettes.html
## x = raster, b1 & b2 = number of divisions for each sequence, r1 & r2 = rounding value
colbr <- function(x, b1=50, b2=50, r1=-2, r2=-2) {
# Min/max values of the raster (x)
mi <- cellStats(x, stat="min")-100
ma <- cellStats(x, stat="max")+100
# Create sequences, but only use unique numbers
s1 <- unique(round(seq(mi, 0, 0-mi/b1),r1))
s2 <- unique(round(seq(0, ma, ma/b2),r2))
# Combine sequence for our break points, removing duplicate 0
s3 <- c(s1, s2[-1])
# Create a list with the outputs
# [[1]] = length of the first sequence minus 1 (water)
# [[2]] = length of the second sequence minus 1 (land)
# [[3]] = The break points
x <- list(length(s1)-1, length(s2)-1, s3)
}
galap.br <- colbr(gebco.crop,b2=1)
# Get country shapefiles
eq <- getData("GADM", country="ECU", level=0)
# Colour palette
blue.col <- colorRampPalette(c("darkblue", "lightblue"))
pdf(width = 8,height=6.5,file="mapBuilding/test.pdf")
plot(gebco.crop, col=c(blue.col(galap.br[[1]]), grey.colors(galap.br[[2]])), breaks=galap.br[[3]],axes = FALSE,box=F,legend = FALSE)
#plot(eq, add=TRUE)
points(metadata$lon2,metadata$lat2,pch=16, col='black',cex=1)
points(metadata$lon2,metadata$lat2,pch=16, col='white',cex=0.5)
dev.off()
gebco <- raster("mapBuilding/GEBCO_2022_sub_ice_topo.nc")
# Create extent (our map area)
galap.ex <- extent(-92, -89, -1.55, 0.65)
# Create a crop of the bathymetric data
gebco.crop <- crop(gebco, galap.ex)
#Save file
saveRDS(gebco.crop,file="mapBuilding/GalapBathy.rds")
gebco.crop <- readRDS("mapBuilding/GalapBathy.rds")
#load lat lon
metadata <- read.csv(file = "metadata.site.out.csv")
#function to calculate break points for colours from https://www.benjaminbell.co.uk/2019/08/bathymetric-maps-in-r-colour-palettes.html
## x = raster, b1 & b2 = number of divisions for each sequence, r1 & r2 = rounding value
colbr <- function(x, b1=50, b2=50, r1=-2, r2=-2) {
# Min/max values of the raster (x)
mi <- cellStats(x, stat="min")-100
ma <- cellStats(x, stat="max")+100
# Create sequences, but only use unique numbers
s1 <- unique(round(seq(mi, 0, 0-mi/b1),r1))
s2 <- unique(round(seq(0, ma, ma/b2),r2))
# Combine sequence for our break points, removing duplicate 0
s3 <- c(s1, s2[-1])
# Create a list with the outputs
# [[1]] = length of the first sequence minus 1 (water)
# [[2]] = length of the second sequence minus 1 (land)
# [[3]] = The break points
x <- list(length(s1)-1, length(s2)-1, s3)
}
galap.br <- colbr(gebco.crop,b2=1)
# Get country shapefiles
eq <- getData("GADM", country="ECU", level=0)
# Colour palette
blue.col <- colorRampPalette(c("darkblue", "lightblue"))
#First plot
pdf(width = 8,height=6.5,file="mapBuilding/test.pdf")
plot(gebco.crop, col=c(blue.col(galap.br[[1]]), grey.colors(galap.br[[2]])), breaks=galap.br[[3]],axes = FALSE,box=F,legend = FALSE)
#plot(eq, add=TRUE)
points(metadata$lon2,metadata$lat2,pch=16, col='black',cex=1)
points(metadata$lon2,metadata$lat2,pch=16, col='white',cex=0.5)
dev.off()
d packages
library(ncdf4)
library(raster)
##Lots of lines hashed out here, original file is 10GB+ so only subset used ;)
#load GEBCO_2022 netcdf downloaded on 110822 - https://www.gebco.net/data_and_products/gridded_bathymetry_data/
gebco <- raster("mapBuilding/GEBCO_2022_sub_ice_topo.nc")
# Create extent (our map area)
galap.ex <- extent(-92, -89, -1.55, 0.68)
# Create a crop of the bathymetric data
gebco.crop <- crop(gebco, galap.ex)
#Save file
saveRDS(gebco.crop,file="mapBuilding/GalapBathy.rds")
gebco.crop <- readRDS("mapBuilding/GalapBathy.rds")
#load lat lon
metadata <- read.csv(file = "metadata.site.out.csv")
#function to calculate break points for colours from https://www.benjaminbell.co.uk/2019/08/bathymetric-maps-in-r-colour-palettes.html
## x = raster, b1 & b2 = number of divisions for each sequence, r1 & r2 = rounding value
colbr <- function(x, b1=50, b2=50, r1=-2, r2=-2) {
# Min/max values of the raster (x)
mi <- cellStats(x, stat="min")-100
ma <- cellStats(x, stat="max")+100
# Create sequences, but only use unique numbers
s1 <- unique(round(seq(mi, 0, 0-mi/b1),r1))
s2 <- unique(round(seq(0, ma, ma/b2),r2))
# Combine sequence for our break points, removing duplicate 0
s3 <- c(s1, s2[-1])
# Create a list with the outputs
# [[1]] = length of the first sequence minus 1 (water)
# [[2]] = length of the second sequence minus 1 (land)
# [[3]] = The break points
x <- list(length(s1)-1, length(s2)-1, s3)
}
galap.br <- colbr(gebco.crop,b2=1)
# Get country shapefiles
eq <- getData("GADM", country="ECU", level=0)
# Colour palette
blue.col <- colorRampPalette(c("darkblue", "lightblue"))
#First plot
pdf(width = 8,height=6.5,file="mapBuilding/test.pdf")
plot(gebco.crop, col=c(blue.col(galap.br[[1]]), grey.colors(galap.br[[2]])), breaks=galap.br[[3]],axes = FALSE,box=F,legend = FALSE)
#plot(eq, add=TRUE)
points(metadata$lon2,metadata$lat2,pch=16, col='black',cex=1)
points(metadata$lon2,metadata$lat2,pch=16, col='white',cex=0.5)
dev.off()
library("metabarTOAD")
library("vegan")
library("Biostrings")
library("RColorBrewer")
library("seqinr")
library("sp")
#### Settings and Setup####
##Get metadata
metadat <- read.csv("metadata.csv")
metadat.site <- read.csv("metadata.site.csv")
#Set some variables
minreads <- 3
items <- NULL
#Set the seed
set.seed("123456")
palette(brewer.pal(12, "Set3"))
metadat.site$lat2 <- as.numeric(paste0(ifelse(substr(metadat.site$latitude,1,1)=="S","-",""),substr(metadat.site$latitude,3,4),".",substr(as.character(as.numeric(paste0(substr(metadat.site$latitude,6,7),".",substr(metadat.site$latitude,9,11)))/60),3,20)))
metadat.site$lon2 <- as.numeric(paste0(ifelse(substr(metadat.site$longitude,1,1)=="W","-",""),substr(metadat.site$longitude,4,5),".",substr(as.character(as.numeric(paste0(substr(metadat.site$longitude,8,9),".",substr(metadat.site$longitude,11,13)))/60),3,20)))
View(metadat.site)
masterTAX <- read.csv("taxonomy/MasterAssignments.csv")
View(masterTAX)
U_fishdat <- read.csv("cleandata/Cleaned.MiFish_U.dada2.lulu.csv")
E_fishdat <- read.csv("cleandata/Cleaned.MiFish_E.dada2.lulu.csv")
View(U_fishdat)
View(E_fishdat)
colnames(U_fishdat)
U_fishdat <- read.csv("cleandata/Cleaned.MiFish_U.dada2.lulu.csv",row.names = 1)
E_fishdat <- read.csv("cleandata/Cleaned.MiFish_E.dada2.lulu.csv",row.names = 1)
colnames(U_fishdat)
colnames(E_fishdat)
colnames(U_fishdat)
?match
match(colnames(U_fishdat),colnames(E_fishdat))
View(masterTAX)
View(masterTAX)
View(masterTAX)
substr(masterTAX$Index)
substr(masterTAX$Index,1)
substr(masterTAX$Index,1,1)
U_fishdat_ASVs <-masterTAX[substr(masterTAX$Index,1,1)==U,]
U_fishdat_ASVs <-masterTAX[substr(masterTAX$Index,1,1)=="U",]
View(U_fishdat_ASVs)
E_fishdat_ASVs <-masterTAX[substr(masterTAX$Index,1,1)=="E",]
match(row.names(E_fishdat),E_fishdat_ASVs$ID)
match(row.names(E_fishdat),E_fishdat_ASVs$ID)
U_masterTAX <-masterTAX[substr(masterTAX$Index,1,1)=="U",]
match(row.names(U_fishdat),U_masterTAX$ID)
U_ASVs <- U_masterTAX$Sequence[match(row.names(U_fishdat),U_masterTAX$ID)]
U_fishdat <- read.csv("cleandata/Cleaned.MiFish_U.dada2.lulu.csv",row.names = 1)
U_masterTAX <-masterTAX[substr(masterTAX$Index,1,1)=="U",]
U_ASVs <- U_masterTAX$Sequence[match(row.names(U_fishdat),U_masterTAX$ID)]
E_fishdat <- read.csv("cleandata/Cleaned.MiFish_E.dada2.lulu.csv",row.names = 1)
E_masterTAX <-masterTAX[substr(masterTAX$Index,1,1)=="E",]
E_ASVs <- E_masterTAX$Sequence[match(row.names(E_fishdat),E_masterTAX$ID)]
colnames(E_fishdat) <- E_ASVs
rownames(E_fishdat) <- E_ASVs
View(E_fishdat)
?prop.table()
colSums(prop.table(U_fishdat,2))
prop.table(U_fishdat,2)
colSums(prop.table(as.matrix(U_fishdat),2))
U_fishdat_p <- prop.table(as.matrix(U_fishdat),2)
U_fishdat_p
#Here we are first reassembling the datasets so they have the ASV seq as the row name
U_fishdat <- read.csv("cleandata/Cleaned.MiFish_U.dada2.lulu.csv",row.names = 1)
U_masterTAX <-masterTAX[substr(masterTAX$Index,1,1)=="U",]
U_ASVs <- U_masterTAX$Sequence[match(row.names(U_fishdat),U_masterTAX$ID)]
rownames(U_fishdat) <- U_ASVs
E_fishdat <- read.csv("cleandata/Cleaned.MiFish_E.dada2.lulu.csv",row.names = 1)
E_masterTAX <-masterTAX[substr(masterTAX$Index,1,1)=="E",]
E_ASVs <- E_masterTAX$Sequence[match(row.names(E_fishdat),E_masterTAX$ID)]
rownames(E_fishdat) <- E_ASVs
U_fishdat_p <-prop.table(as.matrix(U_fishdat),2)
U_fishdat_p
U_fishdat_p*10000000
library(dada2)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("dada2", version = "3.11")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("dada2")
library(dada2)
?collapseNoMismatch()
?makeSequenceTable()
View(E_fishdat)
test <- collapseNoMismatch(E_fishdat)
test <- collapseNoMismatch(as.matrix(E_fishdat))
View(test)
test <- collapseNoMismatch(t(as.matrix(E_fishdat)))
View(test)
U_fishdat_p <-prop.table(as.matrix(U_fishdat),2)
U_fishdat_b <- U_fishdat_p*100000000
E_fishdat_p <-prop.table(as.matrix(E_fishdat),2)
E_fishdat_b <- E_fishdat_p*100000000
rownames(E_fishdat_b)
colnames(E_fishdat_b)
U_fishdat[,match(colnames(U_fishdat),colnames(E_fishdat))])
U_fishdat[,match(colnames(U_fishdat),colnames(E_fishdat))]
U_fishdat_p <-prop.table(as.matrix(U_fishdat[,match(colnames(U_fishdat),colnames(E_fishdat))],2))
U_fishdat_b <- U_fishdat_p*100000000
View(U_fishdat_b)
colnames(E_fishdat)
U_fishdat_p <-prop.table(as.matrix(U_fishdat[,match(colnames(E_fishdat),colnames(U_fishdat))],2))
U_fishdat_b <- U_fishdat_p*100000000
View(U_fishdat_b)
1:length(U_fishdat_p[1,])
plot(1:length(U_fishdat_p[1,]),colnames(E_fishdat),colnames(U_fishdat)))
plot(1:length(U_fishdat_p[1,]),colnames(E_fishdat),colnames(U_fishdat))
plot(1:length(U_fishdat_p[1,]),match(colnames(E_fishdat),colnames(U_fishdat)))
plot(1:length(U_fishdat_p[1,]),match(colnames(E_fishdat),colnames(U_fishdat_b)))
U_fishdat_p <-prop.table(as.matrix(U_fishdat[,match(colnames(E_fishdat),colnames(U_fishdat))],2))
U_fishdat_b <- U_fishdat_p*100000000
E_fishdat_p <-prop.table(as.matrix(E_fishdat),2)
E_fishdat_b <- E_fishdat_p*100000000
colnames(E_fishdat_p)
colnames(E_fishdat_b)
View(U_fishdat_b)
View(U_fishdat_p)
fishdat <- cbind(t(U_fishdat_b),t(E_fishdat_b))
View(fishdat)
str(fishdat)
fishdat_b <- cbind(t(U_fishdat_b),t(E_fishdat_b))
#Here we are first reassembling the datasets so they have the ASV seq as the row name
U_fishdat <- read.csv("cleandata/Cleaned.MiFish_U.dada2.lulu.csv",row.names = 1)
U_masterTAX <-masterTAX[substr(masterTAX$Index,1,1)=="U",]
U_ASVs <- U_masterTAX$Sequence[match(row.names(U_fishdat),U_masterTAX$ID)]
rownames(U_fishdat) <- U_ASVs
E_fishdat <- read.csv("cleandata/Cleaned.MiFish_E.dada2.lulu.csv",row.names = 1)
E_masterTAX <-masterTAX[substr(masterTAX$Index,1,1)=="E",]
E_ASVs <- E_masterTAX$Sequence[match(row.names(E_fishdat),E_masterTAX$ID)]
rownames(E_fishdat) <- E_ASVs
U_fishdat_p <-prop.table(as.matrix(U_fishdat[,match(colnames(E_fishdat),colnames(U_fishdat))],2))
U_fishdat_b <- U_fishdat_p*100000000
E_fishdat_p <-prop.table(as.matrix(E_fishdat),2)
E_fishdat_b <- E_fishdat_p*100000000
fishdat_b <- cbind(t(U_fishdat_b),t(E_fishdat_b))
fishdat_b_collpased <- collapseNoMismatch(fishdat_b)
fishdat_b_collapsed <- collapseNoMismatch(fishdat_b)
str(fishdat_b_collapsed)
fishdat_b_collapsed <- fishdat_b_collapsed/2000000000
fishdat_b_collapsed <- t(collapseNoMismatch(fishdat_b))
fishdat_collapsed <- fishdat_b_collapsed/2000000000
colSum(fishdat_collapsed)
colSums(fishdat_collapsed)
fishdat_collapsed <- fishdat_b_collapsed/200000000
colSums(fishdat_collapsed)
fishdat_collapsed <- fishdat_b_collapsed/100000000
colSums(fishdat_collapsed)
View(fishdat_collapsed)
colSums(E_fishdat_b)
fishdat_b <- cbind(t(U_fishdat_b),t(E_fishdat_b))
rowsums(fishdat_b)
rowSums(fishdat_b)
U_fishdat_p <-prop.table(as.matrix(U_fishdat[,match(colnames(E_fishdat),colnames(U_fishdat))],2))
U_fishdat_b <- U_fishdat_p*100000000
E_fishdat_p <-prop.table(as.matrix(E_fishdat),2)
E_fishdat_b <- E_fishdat_p*100000000
colSums(E_fishdat_b)
colSums(U_fishdat_b)
U_fishdat_p <-prop.table(as.matrix(U_fishdat[,match(colnames(E_fishdat),colnames(U_fishdat))],2))
U_fishdat_p <-prop.table(as.matrix(U_fishdat[,match(colnames(E_fishdat),colnames(U_fishdat))],)2)
U_fishdat_b <- U_fishdat_p*100000000
E_fishdat_p <-prop.table(as.matrix(E_fishdat),2)
E_fishdat_b <- E_fishdat_p*100000000
colSums(E_fishdat_b)
colSums(U_fishdat_b)
U_fishdat_p <-prop.table(as.matrix(U_fishdat[,match(colnames(E_fishdat),colnames(U_fishdat))],)2)
U_fishdat_p <-prop.table(as.matrix(U_fishdat[,match(colnames(E_fishdat),colnames(U_fishdat))]),2)
U_fishdat_b <- U_fishdat_p*100000000
E_fishdat_p <-prop.table(as.matrix(E_fishdat),2)
E_fishdat_b <- E_fishdat_p*100000000
colSums(E_fishdat_b)
colSums(U_fishdat_b)
fishdat_b <- cbind(t(U_fishdat_b),t(E_fishdat_b))
fishdat_b_collapsed <- t(collapseNoMismatch(fishdat_b))
fishdat_collapsed <- fishdat_b_collapsed/100000000
colSums(fishdat_collapsed)
U_fishdat_p <-prop.table(as.matrix(U_fishdat[,match(colnames(E_fishdat),colnames(U_fishdat))]),2)
U_fishdat_b <- U_fishdat_p*100000000
E_fishdat_p <-prop.table(as.matrix(E_fishdat),2)
E_fishdat_b <- E_fishdat_p*100000000
colSums(E_fishdat_b)
colSums(U_fishdat_b)
fishdat_b <- cbind(t(U_fishdat_b),t(E_fishdat_b))
fishdat_b_collapsed <- t(collapseNoMismatch(fishdat_b))
fishdat_collapsed <- fishdat_b_collapsed/200000000
colSums(fishdat_collapsed)
fishdat_RP <- cbind(t(U_fishdat_p),t(E_fishdat_p))
rowSum(fishdat_RP)
rowSums(fishdat_RP)
fishdat_RP_collapsed <- t(collapseNoMismatch(fishdat_RP))
colSums(fishdat_RP_collapsed)
#first we make a relative abundance data (p)
U_fishdat_p <-prop.table(as.matrix(U_fishdat[,match(colnames(E_fishdat),colnames(U_fishdat))]),2)
E_fishdat_p <-prop.table(as.matrix(E_fishdat),2)
colSums(E_fishdat_p)
colSums(U_fishdat_p)
#lets check!
colSums(E_fishdat_p)
colSums(U_fishdat_p)
fishdat_p <- cbind(t(U_fishdat_p),t(E_fishdat_p))
fishdat_p_collapsed <- t(collapseNoMismatch(fishdat_p))
fishdat_collapsed <- fishdat_p_collapsed/2
colSums(fishdat_collapsed)
colSums(fishdat_RP_collapsed)
View(fishdat_collapsed)
