dev.off()
plot(1:10,1:10)
#dir.create("figures/")
pdf("figures/rarefy1.pdf",height = 8,width = 6)
rarecurve(t(alldat),1000,label = F)
rarecurve(t(alldat),1000,label = F)
dev.off()
#dir.create("figures/")
pdf("figures/rarefy1.pdf",height = 8,width = 6)
rarecurve(t(alldat),1000,label = F)
rarecurve(t(alldat),1000,label = F)
dev.off()
plot(1:10,1:10)
#dir.create("figures/")
pdf("figures/rarefy1.pdf",height = 8,width = 6)
rarecurve(t(alldat),1000,label = F)
dev.off()
plot(1:10,1:10)
#dir.create("figures/")
pdf("figures/rarefy1.pdf",height = 8,width = 6)
rarecurve(t(alldat),1000,label = F)
rarecurve(t(alldat),1000,label = F)
dev.off()
#dir.create("figures/")
pdf("figures/rarefy1.pdf",height = 8,width = 6)
rarecurve(t(alldat),1000,label = F)
rarecurve(t(alldat),1000,label = F)
dev.off()
pdf("figures/test.pdf")
plot(1:10,1:10,height = 8,width = 6)
pdf("figures/test.pdf")
plot(1:10,1:10,height = 8,width = 6)
plot(1:10,1:10)
dev.off()
pdf("figures/test.pdf",height = 8,width = 6)
plot(1:10,1:10)
dev.off()
#dir.create("figures/")
rarecurve(t(alldat),1000,label = F)
#dir.create("figures/")
rarecurve(t(alldat),1000,label = F)
```{r}
require("metabarTOAD")
require("lulu")
require("Biostrings")
require("metabarTOAD")
require("lulu")
require("Biostrings")
require("taxize")
#Set some variables
minreads <- 2
items <- NULL
#Set the seed
set.seed("123456")
#Read in metadata
metadata<-read.csv("metadata.csv")
metadata$rep <- sapply(strsplit(metadata$SampleID,","), `[`, 2)
|>
?|>
2 |> sqrt()
|>
2 |> sqrt()
library("metabarTOAD")
library("vegan")
library("Biostrings")
library("RColorBrewer")
library("seqinr")
library("sp")
#### Settings and Setup####
##Get metadata
metadat <- read.csv("metadata.csv")
metadat.site <- read.csv("metadata.site.csv")
#Set some variables
minreads <- 3
items <- NULL
#Set the seed
set.seed("123456")
palette(brewer.pal(12, "Set3"))
metadat.site$lat2 <- as.numeric(paste0("-",substr(metadat.site$latitude,3,4),".",substr(as.character(as.numeric(paste0(substr(metadat.site$latitude,6,7),".",substr(metadat.site$latitude,9,11)))/60),3,20)))
metadat.site$lon2 <- as.numeric(paste0("-",substr(metadat.site$longitude,4,5),".",substr(as.character(as.numeric(paste0(substr(metadat.site$longitude,8,9),".",substr(metadat.site$longitude,11,13)))/60),3,20)))
p.data <- read.csv("/Users/gwm297/GitHubRepos/GalapeDNA/ParticleTracking/AlexData010420.21/1km_new_stats.csv")
View(p.data)
p.data2 <- p.data[p.data$day==3]
p.data$day
p.data2 <- p.data[p.data$day==-3]
p.data2 <- p.data[p.data$day=="-3"]
p.data2 <- p.data[p.data$day=="-3",]
View(p.data2)
plot(p.data2)
plot(p.data2$area..km.,p.data2$ave_dist)
lm(plot(p.data2$area..km.,p.data2$ave_dist))
lm(plot(p.data2$area..km.~p.data2$ave_dist))
lm(p.data2$area..km.~p.data2$ave_dist)
summary(lm(p.data2$area..km.~p.data2$ave_dist))
plot(lm(p.data2$area..km.~p.data2$ave_dist))
plot(p.data2$area..km.,p.data2$ave_dist)
y_val <- 1+ 2*cos(pi*x1)+2/(1+exp(-5*(x2)))
set.seed(2)
n <- 400
x1 <- rnorm(n)
x2 <- rnorm(n)
y_val <- 1+ 2*cos(pi*x1)+2/(1+exp(-5*(x2)))
y_nrom <- y_val+rnorm(n,0,0.5)
y_negbinom <- rnbinom(n,miu=exp(y_val),size=10)
x1 <- rnorm(n)
x2 <- rnorm(n)
y_val <- 1+ 2*cos(pi*x1)+2/(1+exp(-5*(x2)))
y_nrom <- y_val+rnorm(n,0,0.5)
y_negbinom <- rnbinom(n,mu=exp(y_val),size=10)
y_nrom <- y_val+rnorm(n,0,0.5)
y_negbinom <- rnbinom(n,mu=exp(y_val),size=10)
y_binom <- rbinom(n,1,prob=exp(y_val)/(1+exp(y_val)))
set.seed(2)
n <- 400
x1 <- rnorm(n)
x2 <- rnorm(n)
y_val <- 1+ 2*cos(pi*x1)+2/(1+exp(-5*(x2)))
y_nrom <- y_val+rnorm(n,0,0.5)
y_negbinom <- rnbinom(n,mu=exp(y_val),size=10)
y_binom <- rbinom(n,1,prob=exp(y_val)/(1+exp(y_val)))
View(combined_distances.ednasites)
library(metabarTOAD)
MamMeta <- read.csv("mam16s_PSinfo.txt")
View(MamMeta)
MamMeta <- read.table("mam16s_PSinfo.txt",sep="\t")
View(MamMeta)
View(MamMeta)
Mamtags <- read.table("mam16s_tags.txt",sep="\t")
View(Mamtags)
View(MamMeta)
View(Mamtags)
Mamtags$v1[match(Mamtags$V2,MamMeta$V2)]
Mamtags$V1[match(Mamtags$V2,MamMeta$V2)]
Mamtags$V1[match(MamMeta$V2,Mamtags$V2)]
MamMeta$fwdTag <- Mamtags$V1[match(MamMeta$V2,Mamtags$V2)]
MamMeta$revTag <- Mamtags$V1[match(MamMeta$V3,Mamtags$V2)]
View(MamMeta)
paste(MamMeta,1:4)
paste(MamMeta$V1,1:4)
paste0(MamMeta$V1,1:4)
paste0(MamMeta$V1,1:4,sep='.')
paste0(MamMeta$V1,c(1:4),sep='.')
paste(MamMeta$V1,c(1:4),sep='.')
paste(MamMeta$V1,1:4,sep='.')
MamMeta$NewName <- paste(MamMeta$V1,1:4,sep='.')
View(MamMeta)
files <- MamMeta
View(files)
files <- MamMeta
SeqCentreOutput <- "MTOAAirMam16S_S1_L001_R"
SeqCentreOutput <- "MTOAAirMam16S_S1_L001_R"
paste0("--pair-adapters --trimmed-only -g ^",files$fwdTag[loopfile]," -G ^",files$revTag[loopfile]," -j 7 -o ",files$NewName[loopfile],".R1.fastq.gz -p ",files$NewName[loopfile],".R2.fastq.gz ",SeqCentreOutput,"1_001.fastq.gz ",SeqCentreOutput,"2_001.fastq.gz")
loopfile <- 1
paste0("--pair-adapters --trimmed-only -g ^",files$fwdTag[loopfile]," -G ^",files$revTag[loopfile]," -j 7 -o ",files$NewName[loopfile],".R1.fastq.gz -p ",files$NewName[loopfile],".R2.fastq.gz ",SeqCentreOutput,"1_001.fastq.gz ",SeqCentreOutput,"2_001.fastq.gz")
MamMeta <- read.table("mam16s_PSinfo.txt",sep="\t")
Mamtags <- read.table("mam16s_tags.txt",sep="\t")
MamMeta$fwdTag <- Mamtags$V1[match(MamMeta$V2,Mamtags$V2)]
MamMeta$revTag <- Mamtags$V1[match(MamMeta$V3,Mamtags$V2)]
MamMeta$NewName <- paste(MamMeta$V1,1:4,sep='.')
View(MamMeta)
View(MamMeta)
forwards <- list.files("1.rawreads/",pattern="R1.fastq.gz")
reverses <- list.files("1.rawreads/",pattern="R2.fastq.gz")
forwards <- list.files("scratch/",pattern="R1.fastq.gz")
reverses <- list.files("scratch/",pattern="R2.fastq.gz")
forwards <- list.files("scratch/testSet/",pattern="R1.fastq.gz")
reverses <- list.files("scratch/testSet/",pattern="R2.fastq.gz")
forwards.S <- list.files("scratch/testSet/",pattern="S.R1.fastq.gz")
forwards.S <- list.files("scratch/testSet/",pattern="S.R1.fastq.gz")
forwards.A <- list.files("scratch/testSet/",pattern="A.R1.fastq.gz")
reverses.S <- list.files("scratch/testSet/",pattern="S.R2.fastq.gz")
reverses.A <- list.files("scratch/testSet/",pattern="A.R2.fastq.gz")
#a little function to do revcomp
RevComp <- function(input){
require(Biostrings)
dna <- DNAString(input)
dna <- reverseComplement(dna)
return(toString(dna))}
if(length(forwards.S)!=length(reverses.S)){message("Files look good, crack on!")}else{stop("F & R different lengths")}
length(forwards.S)
length(reverses.S)
if(length(forwards.S)!=length(reverses.S)){message("Files look good, crack on!")}else{stop("F & R different lengths")}
loopname <-  gsub("*.R[12].fastq.gz","",forwards.S)
loopname <-  gsub("*.[A|S].R[12].fastq.gz","",forwards.S)
loopname
View(files)
names <-  gsub("*.[A|S].R[12].fastq.gz","",forwards.S)
loopfile <- 1
loopname <- names[loopfile]
loopname
names
paste0("--pair-adapters --trimmed-only -g ^",primerF," -G ^",primerR," -j 7 -o 7.DADA2/trimmed/temp/",loopname,".S.R1.fastq.gz -p 7.DADA2/trimmed/temp/",loopname,".S.R2.fastq.gz 1.rawreads/",loopname,".T.S.R1.fastq.gz 1.rawreads/",loopname,".T.S.R1.fastq.gz")
primerF <- "CGGTTGGGGTGACCTCGGA"   # mammal 16s
primerR <- "GCTGTTATCCCTAGGGTAACT" # mammal 16s
forwards <- list.files("1.rawreads/",pattern="R1.fastq.gz")
reverses <- list.files("1.rawreads/",pattern="R2.fastq.gz")
forwards.S <- list.files("scratch/testSet/",pattern="S.R1.fastq.gz")
forwards.A <- list.files("scratch/testSet/",pattern="A.R1.fastq.gz")
reverses.S <- list.files("scratch/testSet/",pattern="S.R2.fastq.gz")
reverses.A <- list.files("scratch/testSet/",pattern="A.R2.fastq.gz")
paste0("--pair-adapters --trimmed-only -g ^",primerF," -G ^",primerR," -j 7 -o 7.DADA2/trimmed/temp/",loopname,".S.R1.fastq.gz -p 7.DADA2/trimmed/temp/",loopname,".S.R2.fastq.gz 1.rawreads/",loopname,".T.S.R1.fastq.gz 1.rawreads/",loopname,".T.S.R1.fastq.gz")
View(files)
View(MamMeta)
primerF <- "CGGTTGGGGTGACCTCGGA"   # mammal 16s
fnFsSense[57:60]
# Load packages
library(ncdf4)
library(raster)
install.packages("ncdf4","raster")
# Load packages
library(ncdf4)
library(raster)
install.packages(raster")
""
install.packages("raster")
install.packages("raster")
library(raster)
# Load packages
library(ncdf4)
gwtwd
getwd
getwd()
setwd("GitHubRepos/GalapeDNA/")
#load GEBCO_2022 netcdf downloaded on 110822 - https://www.gebco.net/data_and_products/gridded_bathymetry_data/
gebco <- raster("mapBuilding/gebco_2022_sub_ice_topo/GEBCO_2022_sub_ice_topo.nc")
plot(gebco)
nc_open("GEBCO_2019.nc")
nc_open("mapBuilding/gebco_2022_sub_ice_topo/GEBCO_2022_sub_ice_topo.nc")
?getData
?extent
# Create extent (our map area)
galap.ex <- extent(-92.145, -88.1749, -1.8196, 1.8677)
# Create a crop of the bathymetric data
gebco.crop <- crop(gebco, galap.ex)
plot(gebco.crop)
#function from https://www.benjaminbell.co.uk/2019/08/bathymetric-maps-in-r-colour-palettes.html
colbr <- function(x, b1=50, b2=50, r1=-2, r2=-2) {
# Min/max values of the raster (x)
mi <- cellStats(x, stat="min")-100
ma <- cellStats(x, stat="max")+100
# Create sequences, but only use unique numbers
s1 <- unique(round(seq(mi, 0, 0-mi/b1),r1))
s2 <- unique(round(seq(0, ma, ma/b2),r2))
# Combine sequence for our break points, removing duplicate 0
s3 <- c(s1, s2[-1])
# Create a list with the outputs
# [[1]] = length of the first sequence minus 1 (water)
# [[2]] = length of the second sequence minus 1 (land)
# [[3]] = The break points
x <- list(length(s1)-1, length(s2)-1, s3)
}
pr.br <- colbr(gebco.crop)
pr.br
pr.br <- colbr(gebco.crop,b2=100)
pr.br
pr.br <- colbr(gebco.crop,b2=4)
pr.br
?getData()
library("metabarTOAD")
library("vegan")
library("Biostrings")
library("RColorBrewer")
library("seqinr")
library("sp")
#### Settings and Setup####
##Get metadata
metadat <- read.csv("metadata.csv")
metadat.site <- read.csv("metadata.site.csv")
#Set some variables
minreads <- 3
items <- NULL
#Set the seed
set.seed("123456")
palette(brewer.pal(12, "Set3"))
View(metadat.site)
substr(metadat.site$latitude,3,4)
substr(metadat.site$latitude,1,2)
substr(metadat.site$latitude,1,1)
ifelse(substr(metadat.site$latitude,1,1)="S","-","")
ifelse(substr(metadat.site$latitude,1,1)=="S","-","")
metadat.site$lat2 <- as.numeric(paste0(ifelse(substr(metadat.site$latitude,1,1)=="S","-",""),substr(metadat.site$latitude,3,4),".",substr(as.character(as.numeric(paste0(substr(metadat.site$latitude,6,7),".",substr(metadat.site$latitude,9,11)))/60),3,20)))
metadat.site$lon2 <- as.numeric(paste0(ifelse(substr(metadat.site$latitude,1,1)=="S","-",""),substr(metadat.site$longitude,4,5),".",substr(as.character(as.numeric(paste0(substr(metadat.site$longitude,8,9),".",substr(metadat.site$longitude,11,13)))/60),3,20)))
View(metadat.site)
metadat.site$lat2 <- as.numeric(paste0(ifelse(substr(metadat.site$latitude,1,1)=="S","-",""),substr(metadat.site$latitude,3,4),".",substr(as.character(as.numeric(paste0(substr(metadat.site$latitude,6,7),".",substr(metadat.site$latitude,9,11)))/60),3,20)))
metadat.site$lon2 <- as.numeric(paste0(ifelse(substr(metadat.site$latitude,1,1)=="W","-",""),substr(metadat.site$longitude,4,5),".",substr(as.character(as.numeric(paste0(substr(metadat.site$longitude,8,9),".",substr(metadat.site$longitude,11,13)))/60),3,20)))
View(metadat.site)
metadat.site$lat2 <- as.numeric(paste0(ifelse(substr(metadat.site$latitude,1,1)=="S","-",""),substr(metadat.site$latitude,3,4),".",substr(as.character(as.numeric(paste0(substr(metadat.site$latitude,6,7),".",substr(metadat.site$latitude,9,11)))/60),3,20)))
metadat.site$lon2 <- as.numeric(paste0(ifelse(substr(metadat.site$longitude,1,1)=="W","-",""),substr(metadat.site$longitude,4,5),".",substr(as.character(as.numeric(paste0(substr(metadat.site$longitude,8,9),".",substr(metadat.site$longitude,11,13)))/60),3,20)))
View(metadat.site)
metadat.site$lat2 <- as.numeric(paste0(ifelse(substr(metadat.site$latitude,1,1)=="S","-",""),substr(metadat.site$latitude,3,4),".",substr(as.character(as.numeric(paste0(substr(metadat.site$latitude,6,7),".",substr(metadat.site$latitude,9,11)))/60),3,20)))
metadat.site$lon2 <- as.numeric(paste0(ifelse(substr(metadat.site$longitude,1,1)=="W","-",""),substr(metadat.site$longitude,4,5),".",substr(as.character(as.numeric(paste0(substr(metadat.site$longitude,8,9),".",substr(metadat.site$longitude,11,13)))/60),3,20)))
write.csv(metadat,file = "metadata.site.out.csv")
kages
# Load packages
library(ncdf4)
library(raster)
##Lots of lines hashed out here, original file is 10GB+ so only subset used ;)
#load GEBCO_2022 netcdf downloaded on 110822 - https://www.gebco.net/data_and_products/gridded_bathymetry_data/
#gebco <- raster("mapBuilding/gebco_2022_sub_ice_topo/GEBCO_2022_sub_ice_topo.nc")
# Create extent (our map area)
#galap.ex <- extent(-92, -89, -1.55, 0.5)
# Create a crop of the bathymetric data
#gebco.crop <- crop(gebco, galap.ex)
#Save file
#saveRDS(gebco.crop,file="mapBuilding/GalapBathy.rds")
gebco.crop <- readRDS("mapBuilding/GalapBathy.rds")
#load lat lon
metadata <- read.csv(file = "metadata.site.out.csv")
#function to calculate break points for colours from https://www.benjaminbell.co.uk/2019/08/bathymetric-maps-in-r-colour-palettes.html
## x = raster, b1 & b2 = number of divisions for each sequence, r1 & r2 = rounding value
colbr <- function(x, b1=50, b2=50, r1=-2, r2=-2) {
# Min/max values of the raster (x)
mi <- cellStats(x, stat="min")-100
ma <- cellStats(x, stat="max")+100
# Create sequences, but only use unique numbers
s1 <- unique(round(seq(mi, 0, 0-mi/b1),r1))
s2 <- unique(round(seq(0, ma, ma/b2),r2))
# Combine sequence for our break points, removing duplicate 0
s3 <- c(s1, s2[-1])
# Create a list with the outputs
# [[1]] = length of the first sequence minus 1 (water)
# [[2]] = length of the second sequence minus 1 (land)
# [[3]] = The break points
x <- list(length(s1)-1, length(s2)-1, s3)
}
galap.br <- colbr(gebco.crop,b2=1)
# Get country shapefiles
eq <- getData("GADM", country="ECU", level=0)
# Colour palette
blue.col <- colorRampPalette(c("darkblue", "lightblue"))
#First plot
pdf(width = 8,height=6.5,file="mapBuilding/test.pdf")
plot(gebco.crop, col=c(blue.col(galap.br[[1]]), grey.colors(galap.br[[2]])), breaks=galap.br[[3]],axes = FALSE,box=F,legend = FALSE)
#plot(eq, add=TRUE)
points(metadata$lon2,metadata$lat2,pch=16, col='black',cex=1)
points(metadata$lon2,metadata$lat2,pch=16, col='white',cex=0.5)
dev.off()
#load lat lon
metadata <- read.csv(file = "metadata.site.out.csv")
View(metadata)
View(metadata)
#load lat lon
metadata <- read.csv(file = "metadata.site.out.csv")
View(metadat.site)
write.csv(metadat.site,file = "metadata.site.out.csv")
#load lat lon
metadata <- read.csv(file = "metadata.site.out.csv")
gebco.crop <- readRDS("mapBuilding/GalapBathy.rds")
#load lat lon
metadata <- read.csv(file = "metadata.site.out.csv")
#function to calculate break points for colours from https://www.benjaminbell.co.uk/2019/08/bathymetric-maps-in-r-colour-palettes.html
## x = raster, b1 & b2 = number of divisions for each sequence, r1 & r2 = rounding value
colbr <- function(x, b1=50, b2=50, r1=-2, r2=-2) {
# Min/max values of the raster (x)
mi <- cellStats(x, stat="min")-100
ma <- cellStats(x, stat="max")+100
# Create sequences, but only use unique numbers
s1 <- unique(round(seq(mi, 0, 0-mi/b1),r1))
s2 <- unique(round(seq(0, ma, ma/b2),r2))
# Combine sequence for our break points, removing duplicate 0
s3 <- c(s1, s2[-1])
# Create a list with the outputs
# [[1]] = length of the first sequence minus 1 (water)
# [[2]] = length of the second sequence minus 1 (land)
# [[3]] = The break points
x <- list(length(s1)-1, length(s2)-1, s3)
}
galap.br <- colbr(gebco.crop,b2=1)
# Get country shapefiles
eq <- getData("GADM", country="ECU", level=0)
# Colour palette
blue.col <- colorRampPalette(c("darkblue", "lightblue"))
#First plot
pdf(width = 8,height=6.5,file="mapBuilding/test.pdf")
plot(gebco.crop, col=c(blue.col(galap.br[[1]]), grey.colors(galap.br[[2]])), breaks=galap.br[[3]],axes = FALSE,box=F,legend = FALSE)
#plot(eq, add=TRUE)
points(metadata$lon2,metadata$lat2,pch=16, col='black',cex=1)
points(metadata$lon2,metadata$lat2,pch=16, col='white',cex=0.5)
dev.off()
View(metadat.site)
##Lots of lines hashed out here, original file is 10GB+ so only subset used ;)
#load GEBCO_2022 netcdf downloaded on 110822 - https://www.gebco.net/data_and_products/gridded_bathymetry_data/
gebco <- raster("mapBuilding/gebco_2022_sub_ice_topo/GEBCO_2022_sub_ice_topo.nc")
##Lots of lines hashed out here, original file is 10GB+ so only subset used ;)
#load GEBCO_2022 netcdf downloaded on 110822 - https://www.gebco.net/data_and_products/gridded_bathymetry_data/
gebco <- raster("mapBuilding/gebco_2022_sub_ice_topo/GEBCO_2022_sub_ice_topo.nc")
##Lots of lines hashed out here, original file is 10GB+ so only subset used ;)
#load GEBCO_2022 netcdf downloaded on 110822 - https://www.gebco.net/data_and_products/gridded_bathymetry_data/
gebco <- raster("mapBuilding/GEBCO_2022_sub_ice_topo.nc")
##Lots of lines hashed out here, original file is 10GB+ so only subset used ;)
#load GEBCO_2022 netcdf downloaded on 110822 - https://www.gebco.net/data_and_products/gridded_bathymetry_data/
gebco <- raster("mapBuilding/GEBCO_2022_sub_ice_topo.nc")
# Create extent (our map area)
galap.ex <- extent(-92, -89, -1.55, 0.63)
# Create a crop of the bathymetric data
gebco.crop <- crop(gebco, galap.ex)
#Save file
saveRDS(gebco.crop,file="mapBuilding/GalapBathy.rds")
gebco.crop <- readRDS("mapBuilding/GalapBathy.rds")
#load lat lon
metadata <- read.csv(file = "metadata.site.out.csv")
#function to calculate break points for colours from https://www.benjaminbell.co.uk/2019/08/bathymetric-maps-in-r-colour-palettes.html
## x = raster, b1 & b2 = number of divisions for each sequence, r1 & r2 = rounding value
colbr <- function(x, b1=50, b2=50, r1=-2, r2=-2) {
# Min/max values of the raster (x)
mi <- cellStats(x, stat="min")-100
ma <- cellStats(x, stat="max")+100
# Create sequences, but only use unique numbers
s1 <- unique(round(seq(mi, 0, 0-mi/b1),r1))
s2 <- unique(round(seq(0, ma, ma/b2),r2))
# Combine sequence for our break points, removing duplicate 0
s3 <- c(s1, s2[-1])
# Create a list with the outputs
# [[1]] = length of the first sequence minus 1 (water)
# [[2]] = length of the second sequence minus 1 (land)
# [[3]] = The break points
x <- list(length(s1)-1, length(s2)-1, s3)
}
galap.br <- colbr(gebco.crop,b2=1)
# Get country shapefiles
eq <- getData("GADM", country="ECU", level=0)
# Colour palette
blue.col <- colorRampPalette(c("darkblue", "lightblue"))
pdf(width = 8,height=6.5,file="mapBuilding/test.pdf")
plot(gebco.crop, col=c(blue.col(galap.br[[1]]), grey.colors(galap.br[[2]])), breaks=galap.br[[3]],axes = FALSE,box=F,legend = FALSE)
#plot(eq, add=TRUE)
points(metadata$lon2,metadata$lat2,pch=16, col='black',cex=1)
points(metadata$lon2,metadata$lat2,pch=16, col='white',cex=0.5)
dev.off()
gebco <- raster("mapBuilding/GEBCO_2022_sub_ice_topo.nc")
# Create extent (our map area)
galap.ex <- extent(-92, -89, -1.55, 0.65)
# Create a crop of the bathymetric data
gebco.crop <- crop(gebco, galap.ex)
#Save file
saveRDS(gebco.crop,file="mapBuilding/GalapBathy.rds")
gebco.crop <- readRDS("mapBuilding/GalapBathy.rds")
#load lat lon
metadata <- read.csv(file = "metadata.site.out.csv")
#function to calculate break points for colours from https://www.benjaminbell.co.uk/2019/08/bathymetric-maps-in-r-colour-palettes.html
## x = raster, b1 & b2 = number of divisions for each sequence, r1 & r2 = rounding value
colbr <- function(x, b1=50, b2=50, r1=-2, r2=-2) {
# Min/max values of the raster (x)
mi <- cellStats(x, stat="min")-100
ma <- cellStats(x, stat="max")+100
# Create sequences, but only use unique numbers
s1 <- unique(round(seq(mi, 0, 0-mi/b1),r1))
s2 <- unique(round(seq(0, ma, ma/b2),r2))
# Combine sequence for our break points, removing duplicate 0
s3 <- c(s1, s2[-1])
# Create a list with the outputs
# [[1]] = length of the first sequence minus 1 (water)
# [[2]] = length of the second sequence minus 1 (land)
# [[3]] = The break points
x <- list(length(s1)-1, length(s2)-1, s3)
}
galap.br <- colbr(gebco.crop,b2=1)
# Get country shapefiles
eq <- getData("GADM", country="ECU", level=0)
# Colour palette
blue.col <- colorRampPalette(c("darkblue", "lightblue"))
#First plot
pdf(width = 8,height=6.5,file="mapBuilding/test.pdf")
plot(gebco.crop, col=c(blue.col(galap.br[[1]]), grey.colors(galap.br[[2]])), breaks=galap.br[[3]],axes = FALSE,box=F,legend = FALSE)
#plot(eq, add=TRUE)
points(metadata$lon2,metadata$lat2,pch=16, col='black',cex=1)
points(metadata$lon2,metadata$lat2,pch=16, col='white',cex=0.5)
dev.off()
d packages
library(ncdf4)
library(raster)
##Lots of lines hashed out here, original file is 10GB+ so only subset used ;)
#load GEBCO_2022 netcdf downloaded on 110822 - https://www.gebco.net/data_and_products/gridded_bathymetry_data/
gebco <- raster("mapBuilding/GEBCO_2022_sub_ice_topo.nc")
# Create extent (our map area)
galap.ex <- extent(-92, -89, -1.55, 0.68)
# Create a crop of the bathymetric data
gebco.crop <- crop(gebco, galap.ex)
#Save file
saveRDS(gebco.crop,file="mapBuilding/GalapBathy.rds")
gebco.crop <- readRDS("mapBuilding/GalapBathy.rds")
#load lat lon
metadata <- read.csv(file = "metadata.site.out.csv")
#function to calculate break points for colours from https://www.benjaminbell.co.uk/2019/08/bathymetric-maps-in-r-colour-palettes.html
## x = raster, b1 & b2 = number of divisions for each sequence, r1 & r2 = rounding value
colbr <- function(x, b1=50, b2=50, r1=-2, r2=-2) {
# Min/max values of the raster (x)
mi <- cellStats(x, stat="min")-100
ma <- cellStats(x, stat="max")+100
# Create sequences, but only use unique numbers
s1 <- unique(round(seq(mi, 0, 0-mi/b1),r1))
s2 <- unique(round(seq(0, ma, ma/b2),r2))
# Combine sequence for our break points, removing duplicate 0
s3 <- c(s1, s2[-1])
# Create a list with the outputs
# [[1]] = length of the first sequence minus 1 (water)
# [[2]] = length of the second sequence minus 1 (land)
# [[3]] = The break points
x <- list(length(s1)-1, length(s2)-1, s3)
}
galap.br <- colbr(gebco.crop,b2=1)
# Get country shapefiles
eq <- getData("GADM", country="ECU", level=0)
# Colour palette
blue.col <- colorRampPalette(c("darkblue", "lightblue"))
#First plot
pdf(width = 8,height=6.5,file="mapBuilding/test.pdf")
plot(gebco.crop, col=c(blue.col(galap.br[[1]]), grey.colors(galap.br[[2]])), breaks=galap.br[[3]],axes = FALSE,box=F,legend = FALSE)
#plot(eq, add=TRUE)
points(metadata$lon2,metadata$lat2,pch=16, col='black',cex=1)
points(metadata$lon2,metadata$lat2,pch=16, col='white',cex=0.5)
dev.off()
