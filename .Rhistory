environemental.data=envData)
envData
sppData <- SimulateSpp(length.of.record=100,
strength.of.effect=0.8,
rarity.of.species=0.5,
environmental.data=envData)
## This function creates a timeseries vector that
SimulateSpp <- function(length.of.record,strength.of.effect,rarity.of.species,environmental.data){
#make a little dataframe to catch the result
output <- rep(0,length.of.record)
#some initial data from a poisson distribution using the rarity of species parameter as input
output <- output + rpois(length.of.record,rarity.of.species*100)
#add in the effect of the env variable
output <- (output + sum(output)*(environmental.data/sum(environmental.data)*strength.of.effect))/2
#now we add some random drop outs
output[rbinom(length.of.record,1,stochastic.of.species)==1] <- 0
}
sppData <- SimulateSpp(length.of.record=100,
strength.of.effect=0.8,
rarity.of.species=0.5,
environmental.data=envData)
plot(sppData)
SimulateSpp(length.of.record=100,
strength.of.effect=0.8,
rarity.of.species=0.5,
environmental.data=envData)
]
SimulateSpp(length.of.record=100,
strength.of.effect=0.8,
rarity.of.species=0.5,
environmental.data=envData)
SimulateSpp(length.of.record=100,
strength.of.effect=0.8,
rarity.of.species=0.5,
environmental.data=envData)
## This function creates a timeseries vector that
SimulateSpp <- function(length.of.record,strength.of.effect,rarity.of.species,environmental.data){
#make a little dataframe to catch the result
output <- rep(0,length.of.record)
#some initial data from a poisson distribution using the rarity of species parameter as input
output <- output + rpois(length.of.record,rarity.of.species*100)
#add in the effect of the env variable
output <- (output + sum(output)*(environmental.data/sum(environmental.data)*strength.of.effect))/2
#now we add some random drop outs
output[rbinom(length.of.record,1,stochastic.of.species)==1] <- 0
return(output)
}
envData <- SimulateEnv(length.of.record=100,
type="sigmoid",
shape=0.5,
magnitude=100,
random=0.05)
sppData <- SimulateSpp(length.of.record=100,
strength.of.effect=0.8,
rarity.of.species=0.5,
environmental.data=envData)
plot(sppData)
envData <- SimulateEnv(length.of.record=100,
type="sigmoid",
shape=1,
magnitude=100,
random=0.05)
sppData <- SimulateSpp(length.of.record=100,
strength.of.effect=0.8,
rarity.of.species=0.5,
environmental.data=envData)
sppData
#This function returns a vector of size N representing an environmental variable that
#varies across the space according to type, shape, magnitude and randomness
SimulateEnv <- function(length.of.record,type,shape,magnitude,random){
if(type=="linear"){
envOut <- 1:length.of.record*shape+magnitude
envOut <- envOut + rnorm(length.of.record,0,random*magnitude)
return(envOut)
}else if(type=="sigmoid"){
envOut <- tanh(seq(-(shape*3),(shape*3),length.out=length.of.record))*magnitude
envOut <- envOut + rnorm(length.of.record,0,random*max(envOut))
envOut <- envOut-min(envOut)
return(envOut)
}else{stop("Variable type not defined")}
}
## This function creates a timeseries vector that
SimulateSpp <- function(length.of.record,strength.of.effect,rarity.of.species,environmental.data){
#make a little dataframe to catch the result
output <- rep(0,length.of.record)
#some initial data from a poisson distribution using the rarity of species parameter as input
output <- output + rpois(length.of.record,rarity.of.species*100)
#add in the effect of the env variable
output <- (output + sum(output)*(environmental.data/sum(environmental.data)*strength.of.effect))/2
#now we add some random drop outs
output[rbinom(length.of.record,1,stochastic.of.species)==1] <- 0
return(output)
}
envData <- SimulateEnv(length.of.record=100,
type="sigmoid",
shape=1,
magnitude=100,
random=0.05)
envData
plot(envData)
sppData <- SimulateSpp(length.of.record=100,
strength.of.effect=0.8,
rarity.of.species=0.5,
environmental.data=envData)
## This function creates a timeseries vector that
SimulateSpp <- function(length.of.record,strength.of.effect,rarity.of.species,stochastic.of.species,environmental.data){
#make a little dataframe to catch the result
output <- rep(0,length.of.record)
#some initial data from a poisson distribution using the rarity of species parameter as input
output <- output + rpois(length.of.record,rarity.of.species*100)
#add in the effect of the env variable
output <- (output + sum(output)*(environmental.data/sum(environmental.data)*strength.of.effect))/2
#now we add some random drop outs
output[rbinom(length.of.record,1,stochastic.of.species)==1] <- 0
return(output)
}
envData <- SimulateEnv(length.of.record=100,
type="sigmoid",
shape=1,
magnitude=100,
random=0.05)
sppData <- SimulateSpp(length.of.record=100,
strength.of.effect=0.8,
rarity.of.species=0.5,
stochastic.of.species=0.01
environmental.data=envData)
sppData <- SimulateSpp(length.of.record=100,
strength.of.effect=0.8,
rarity.of.species=0.5,
stochastic.of.species=0.01,
environmental.data=envData)
plot(sppData)
envData <- SimulateEnv(length.of.record=20,
type="sigmoid",
shape=1,
magnitude=100,
random=0.05)
sppData <- SimulateSpp(length.of.record=20,
strength.of.effect=0.8,
rarity.of.species=0.5,
stochastic.of.species=0.01,
environmental.data=envData)
plot(sppData)
envData <- SimulateEnv(length.of.record=20,
type="sigmoid",
shape=1,
magnitude=100,
random=0.05)
sppData <- SimulateSpp(length.of.record=20,
strength.of.effect=0.8,
rarity.of.species=0.5,
stochastic.of.species=0.01,
environmental.data=envData)
plot(sppData)
envData <- SimulateEnv(length.of.record=20,
type="sigmoid",
shape=1,
magnitude=100,
random=0.05)
sppData <- SimulateSpp(length.of.record=20,
strength.of.effect=0.8,
rarity.of.species=0.5,
stochastic.of.species=0.01,
environmental.data=envData)
plot(sppData)
envData <- SimulateEnv(length.of.record=50,
type="sigmoid",
shape=1,
magnitude=100,
random=0.05)
sppData <- SimulateSpp(length.of.record=50,
strength.of.effect=0.8,
rarity.of.species=0.5,
stochastic.of.species=0.01,
environmental.data=envData)
plot(sppData)
plot(sppData)
plot(sppData)
plot(sppData)
plot(1:50,sppData)
plot(sppData)
####====0.0 Packages====####
library("vegan")
library("RColorBrewer")
#Set the seed
set.seed("123456")
palette(brewer.pal(12, "Set3"))
####====1.0 Pull in Data ====####
#Fish first
fishAll <- read.csv("cleandata/Cleaned_Fish_wTAX.csv",row.names=1)
#calculate some distances 'as-the-fish-swims'
####====0.0 Packages====####
library('gdistance')
library('sf')
library('geosphere')
#Pull in galapagos
gebco.crop <- readRDS("mapBuilding/GalapBathy.rds")
#
tr1 <- transition(gebco.crop2, transitionFunction=mean, directions=16)
tr2 <- geoCorrection(tr1, type="r", multpl=TRUE)
sitePairwiseDist$Flat <- metadatSites$lat2[match(sitePairwiseDist$Start,metadatSites$SiteID)]
sitePairwiseDist$Flon <- metadatSites$lon2[match(sitePairwiseDist$Start,metadatSites$SiteID)]
sitePairwiseDist$Tlat <- metadatSites$lat2[match(sitePairwiseDist$End,metadatSites$SiteID)]
sitePairwiseDist$Tlon <- metadatSites$lon2[match(sitePairwiseDist$End,metadatSites$SiteID)]
sitePairwiseDist$Calcdistance <- rep(NA,length(sitePairwiseDist$End))
pathPointsTable <- c()
for (row in 1:length(sitePairwiseDist$End)){
#set dist to zero and skip loop for comparing a site to itself
if(sitePairwiseDist$Start[row]==sitePairwiseDist$End[row]){sitePairwiseDist$Calcdistance[row] <- 0
next()}
#get the shortest path
loopPath <- shortestPath(tr2, c(sitePairwiseDist$Flon[row],
sitePairwiseDist$Flat[row]),
c(sitePairwiseDist$Tlon[row],
sitePairwiseDist$Tlat[row]), output="SpatialLines")
#calculate the distance of the shortest path
looplen <- lengthLine(loopPath)
#sample points along the path every 1000 metres
loopPathpoints <- spsample(loopPath,looplen/1000,type="regular")
#output lengths to dataframe
sitePairwiseDist$Calcdistance[row] <- looplen
#create point output table
loopPathPointsize <- length(loopPathpoints)
loopPointsTable <- data.frame("Order"=1:loopPathPointsize,
"Start"=rep(sitePairwiseDist$Start[row],loopPathPointsize),
"End"=rep(sitePairwiseDist$End[row],loopPathPointsize),
"lon"=loopPathpoints@coords[,1],
"lat"=loopPathpoints@coords[,2])
pathPointsTable <- rbind(pathPointsTable,loopPointsTable)
print(row)
}
#First the angle
vectorAngle <- function(Northing,Easting){
if(Northing == 0 & Easting == 0){return(NA)}
resultant_angle <- atan2(sqrt(Northing^2),sqrt(Easting^2))
resultant_angle_degrees <- (180/pi) * resultant_angle
if(Northing>0 & Easting>0){return(90-resultant_angle_degrees)} else
if(Northing<0 & Easting>0){return(90+resultant_angle_degrees)} else
if(Northing<0 & Easting<0){return(270-resultant_angle_degrees)} else
if(Northing>0 & Easting<0){return(270+resultant_angle_degrees)}
}
#calculate some distances 'as-the-fish-swims'
####====0.0 Packages====####
library('gdistance')
library('sf')
library('geosphere')
####====1.0 As-the-fish-swims Distance & Points  ====####
#Pull in galapagos
gebco.crop <- readRDS("mapBuilding/GalapBathy.rds")
###
data <- read.csv("Desktop/DabV/data.xlsx")
View(data)
###
data <- readxl::("Desktop/DabV/data.xlsx")
###
data <- readxl("Desktop/DabV/data.xlsx")
###
data <- read.csv("Desktop/DabV/data.csv")
View(data)
View(data)
plot(data$Drops~data$Type)
plot(data$Drops,data$Type)
dev.off()
plot(data$Drops~data$Type)
View(data)
plot(data$Dropsx)
plot(data$Drops)
hist(data$Drops)
plot(data$Drops)
plot(data$Drops~data$Drops)
plot(data$Drops~as.factor(data$Drops))
plot(data$Drops~as.factor(data$Type))
anova(data$Drops~as.factor(data$Type))
aov(data$Drops~as.factor(data$Type))
model1 <- aov(data$Drops~as.factor(data$Type))
summarry(model1)
summary(model1)
TukeyHSD(model1)
###
data <- read.csv("Desktop/DabV/data.csv")
plot(data$Drops~as.factor(data$Type))
model1 <- aov(data$Drops~as.factor(data$Type))
summary(model1)
TukeyHSD(model1)
data <- data.frame(
group = rep(c("A", "B", "C"), each = 20),
value = rnorm(60)
)
# Create vector to map x-axis variable to
x_vec <- c("Group A", "Group B", "Group C")
# Create box and whisker plot with x-axis mapped to vector
ggplot(data, aes(x = factor(group, levels = c("A", "B", "C")), y = value)) +
geom_boxplot() +
scale_x_discrete(labels = x_vec)
library(ggplot2)
data <- data.frame(
group = rep(c("A", "B", "C"), each = 20),
value = rnorm(60)
)
# Create vector to map x-axis variable to
x_vec <- c("Group A", "Group B", "Group C")
# Create box and whisker plot with x-axis mapped to vector
ggplot(data, aes(x = factor(group, levels = c("A", "B", "C")), y = value)) +
geom_boxplot() +
scale_x_discrete(labels = x_vec)
?scale_x_discrete
data <- data.frame(
group = rep(c("A", "B", "C"), each = 20),
value = rnorm(60)
)
# Create vector to map x-axis variable to
x_vec <- c("Group A", "Group B", "Group C")
# Create box and whisker plot with x-axis mapped to vector
ggplot(data, aes(x = factor(group, levels = c("A", "B", "C")), y = value)) +
geom_boxplot() +
scale_x_discrete(labels = x_vec,expand=c(1,2,22))
data <- data.frame(
group = rep(c("A", "B", "C"), each = 20),
value = rnorm(60)
)
# Create vector to map x-axis variable to
x_vec <- c("Group A", "Group B", "Group C")
# Create box and whisker plot with x-axis mapped to vector
ggplot(data, aes(x = factor(group, levels = c("A", "B", "C")), y = value)) +
geom_boxplot() +
scale_x_continuous(labels = x_vec)
data <- data.frame(
group = rep(c("A", "B", "C"), each = 20),
value = rnorm(60)
)
# Create vector to map x-axis variable to
x_vec <- c("Group A", "Group B", "Group C")
# Create box and whisker plot with x-axis mapped to vector
ggplot(data, aes(x = factor(group, levels = c("A", "B", "C")), y = value)) +
geom_boxplot() +
scale_x_continuous(labels = c(1,2,12))
set.seed(123)
data <- data.frame(
group = rep(c("A", "B", "C"), each = 20),
value = rnorm(60)
)
# Specify x-axis breaks and labels
x_breaks <- c(1, 3, 22)
x_labels <- c("Group A", "Group B", "Group C")
# Create box and whisker plot with custom x-axis breaks and labels
ggplot(data, aes(x = group, y = value)) +
geom_boxplot() +
scale_x_continuous(breaks = x_breaks, labels = x_labels)
set.seed(123)
data <- data.frame(
group = rep(c("A", "B", "C"), each = 20),
value = rnorm(60)
)
# Specify x-axis breaks and labels
x_breaks <- c(1, 3, 22)
x_labels <- c("Group A", "Group B", "Group C")
# Create box and whisker plot with custom x-axis breaks and labels
ggplot(data, aes(x = group, y = value)) +
geom_boxplot() +
scale_x_continuous(breaks = x_breaks, labels = x_labels)
x_breaks
str(x_breaks)
# Create example data
set.seed(123)
data <- data.frame(
group = rep(c("A", "B", "C"), each = 20),
value = rnorm(60)
)
# Specify x-axis breaks and labels as discrete values
x_breaks <- c("A", "B", "C")
x_labels <- c("Group A", "Group B", "Group C")
# Create box and whisker plot with custom x-axis breaks and labels
ggplot(data, aes(x = group, y = value)) +
geom_boxplot() +
scale_x_discrete(breaks = x_breaks, labels = x_labels)
# Create box and whisker plot with custom x-axis breaks and labels
ggplot(data, aes(x = group, y = value)) +
geom_boxplot() +
scale_x_continuous(breaks = x_breaks, labels = x_labels)
#primer information
Euk18S <- c("GTACACACCGCCCGTC","TGATCCTTCTGCAGGTTCACCTAC","18S","EUK")
Riaz12S <-c("TTAGATACCCCACTATGC","TAGAACAGGCTCCTCTAG","12S","RIZ")
Mamm16S <- c("CGGTTGGGGTGACCTCGGA","GCTGTTATCCCTAGGGTAACT","16S","MAM")
primerSets <- as.data.frame(rbind(Euk18S,Riaz12S,Mamm16S))
#a little function to do revcomp
RevComp <- function(input){
require(Biostrings)
dna <- DNAString(input)
dna <- reverseComplement(dna)
return(toString(dna))}
RevComp(Euk18S[2])
getwd()
setwd("GitHubRepos/GalapeDNA")
library("metabarTOAD")
library("vegan")
library("Biostrings")
library("RColorBrewer")
library("seqinr")
library("sp")
library("dada2")
#### Settings and Setup####
##Get metadata
metadat <- read.csv("metadata.csv")
metadat.site <- read.csv("metadata.site.csv")
#Set some variables
minreads <- 3
items <- NULL
#Set the seed
set.seed("123456")
palette(brewer.pal(12, "Set3"))
#Change the location to sensible numbers
metadat.site$lat2 <- as.numeric(paste0(ifelse(substr(metadat.site$latitude,1,1)=="S","-",""),substr(metadat.site$latitude,3,4),".",substr(as.character(as.numeric(paste0(substr(metadat.site$latitude,6,7),".",substr(metadat.site$latitude,9,11)))/60),3,20)))
metadat.site$lon2 <- as.numeric(paste0(ifelse(substr(metadat.site$longitude,1,1)=="W","-",""),substr(metadat.site$longitude,4,5),".",substr(as.character(as.numeric(paste0(substr(metadat.site$longitude,8,9),".",substr(metadat.site$longitude,11,13)))/60),3,20)))
write.csv(metadat.site,file = "metadata.site.out.csv")
files <- list.files("rawdata",full.names = T)
for (file in  files){
rawdat <-read.csv(file=file)
#Separate controls and samples
samples <- rawdat[colnames(rawdat) %in% metadat$SiteID[metadat$SiteType=="sample"]]
controls <- rawdat[colnames(rawdat) %in% metadat$SiteID[metadat$SiteType=="control.N"]]
#get taxonomy for controls and get rid of OTUs unrepresented
controls <- controls[rowSums(controls) > 0,]
if(length(grep("U",basename(file)))==1){
Controlassigntrunc <- data.frame(matrix(nrow= dim(controls)[1],ncol=10))
rownames(Controlassigntrunc) <- rownames(controls)
colnames(Controlassigntrunc) <- colnames(MiUassignments)
for (row in 1:dim(controls)[1]){
if(!rownames(controls)[row] %in% MiUassignments$OTU){
next()}
Controlassigntrunc[rownames(controls)[row],] <- MiUassignments[rownames(controls)[row]==MiUassignments$OTU,]
}
controls <- cbind(controls,Controlassigntrunc)
} else if(length(grep("E",basename(file)))==1){
Controlassigntrunc <- data.frame(matrix(nrow= dim(controls)[1],ncol=10))
rownames(Controlassigntrunc) <- rownames(controls)
colnames(Controlassigntrunc) <- colnames(MiEassignments)
for (row in 1:dim(controls)[1]){
if(!rownames(controls)[row] %in% MiEassignments$OTU){
next()}
Controlassigntrunc[rownames(controls)[row],] <- MiEassignments[rownames(controls)[row]==MiEassignments$OTU,]
}
controls <- cbind(controls,Controlassigntrunc)
}
#Filter 1 - minimum number of reads for any ID
samples[samples< minreads] <- 0
samples <- samples[rowSums(samples) > 0,]
#Filter 2 -Make the sum number of reads for each OTU across all control samples in the contam the zero value in the main data
controlsCONTAM <- controls[,-((dim(controls)[2]-10):dim(controls)[2])]
controlsCONTAM <- controlsCONTAM[rowSums(controlsCONTAM) > 0,]
for (contamOTU in 1:length(controlsCONTAM[,1])){
loopOTU <- row.names(controlsCONTAM[contamOTU,])
loopMax <- sum(as.numeric(controlsCONTAM[contamOTU,]))
if (any(is.na(samples[loopOTU,]))){next}
samples[loopOTU,samples[loopOTU,]<loopMax] <- 0
print(paste("Cleaning contaminants",contamOTU))
}
samples <- samples[rowSums(samples) > 0,]
newname <- paste("cleandata/","Cleaned.",basename(file),sep="")
newname.control <- paste("controldata/","Control.N.",basename(file),sep="")
write.csv(samples,file=newname)
write.csv(controls,file=newname.control)
}
#Here we are first reassembling the datasets so they have the ASV seq as the row name
U_fishdat <- read.csv("cleandata/Cleaned.MiFish_U.dada2.lulu.csv",row.names = 1)
E_fishdat <- read.csv("cleandata/Cleaned.MiFish_E.dada2.lulu.csv",row.names = 1)
fishdat_p <- cbind(t(U_fishdat_p),t(E_fishdat_p))
#first we make a relative abundance data (p)
U_fishdat_p <-prop.table(as.matrix(U_fishdat[,match(colnames(E_fishdat),colnames(U_fishdat))]),2)
E_fishdat_p <-prop.table(as.matrix(E_fishdat),2)
#lets check!
colSums(E_fishdat_p)
colSums(U_fishdat_p)
fishdat_p <- cbind(t(U_fishdat_p),t(E_fishdat_p))
fishdat_p_collapsed <- t(collapseNoMismatch(fishdat_p))
View(fishdat_p_collapsed)
View(E_fishdat)
masterTAX <- read.csv("taxonomy/MasterAssignments.csv")
#combine identical or subset seqs
#Here we are first reassembling the datasets so they have the ASV seq as the row name
U_fishdat <- read.csv("cleandata/Cleaned.MiFish_U.dada2.lulu.csv",row.names = 1)
U_masterTAX <-masterTAX[substr(masterTAX$Index,1,1)=="U",]
U_ASVs <- U_masterTAX$Sequence[match(row.names(U_fishdat),U_masterTAX$ID)]
rownames(U_fishdat) <- U_ASVs
E_fishdat <- read.csv("cleandata/Cleaned.MiFish_E.dada2.lulu.csv",row.names = 1)
E_masterTAX <-masterTAX[substr(masterTAX$Index,1,1)=="E",]
E_ASVs <- E_masterTAX$Sequence[match(row.names(E_fishdat),E_masterTAX$ID)]
rownames(E_fishdat) <- E_ASVs
#Now as the samples have different numbers of reads between each marker we switch to relative abundance and use the dada2 function collapse no mismatch
#first we make a relative abundance data (p)
U_fishdat_p <-prop.table(as.matrix(U_fishdat[,match(colnames(E_fishdat),colnames(U_fishdat))]),2)
E_fishdat_p <-prop.table(as.matrix(E_fishdat),2)
#lets check!
colSums(E_fishdat_p)
colSums(U_fishdat_p)
View(E_fishdat)
fishdat_p <- cbind(t(U_fishdat_p),t(E_fishdat_p))
fishdat_p_collapsed <- t(collapseNoMismatch(fishdat_p))
test <- as.data.frame(fishdat_p_collapsed)
dim(test)
#### Settings and Setup####
##Get metadata
metadat <- read.csv("metadata.csv")
metadat.site <- read.csv("metadata.site.csv")
#Set some variables
minreads <- 3
items <- NULL
#Set the seed
set.seed("123456")
palette(brewer.pal(12, "Set3"))
metadat.site$lat2 <- as.numeric(paste0(ifelse(substr(metadat.site$latitude,1,1)=="S","-",""),substr(metadat.site$latitude,3,4),".",substr(as.character(as.numeric(paste0(substr(metadat.site$latitude,6,7),".",substr(metadat.site$latitude,9,11)))/60),3,20)))
metadat.site$lon2 <- as.numeric(paste0(ifelse(substr(metadat.site$longitude,1,1)=="W","-",""),substr(metadat.site$longitude,4,5),".",substr(as.character(as.numeric(paste0(substr(metadat.site$longitude,8,9),".",substr(metadat.site$longitude,11,13)))/60),3,20)))
write.csv(metadat.site,file = "metadata.site.out.csv")
